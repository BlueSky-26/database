# 第一天：Linux操作系统

## vmware及ubuntu安装

### vmware安装（参考）：

1. 解压已下载的“VMware.Workstation.v14.0.0.Win.rar”，然后进入解压后的目录，双击“VMware-workstation-full-14.0.0-6661328.exe”启动VMware Workstation 14 Pro安装程序；
2. 在弹出的“欢迎”窗口中，点击“下一步”按钮进入下一步；
3. 在弹出的“最终用户协议”窗口中，勾选“我接受许可协议中的条款”复选框，然后点击“下一步”按钮进入下一步；
4. 在弹出的“自定义安装”窗口中，可以点击“更改”按钮选择VMware Workstation的安装目录（本教程中采用默认目录）。选定安装位置后，勾选“增强型键盘驱动程序”，然后点击“下一步”按钮进入下一步；
5. 在弹出的“用户体验设置”窗口中，去掉“启动时检查产品更新”和“帮助完善VMware Workstation Pro（H）”复选框前的勾，然后点击“下一步”按钮进入下一步；
6. 在弹出的“快捷方式”窗口中，直接点击“下一步”按钮进入下一步；
7. 在弹出的“已准备好安装VMware Workstation Pro”窗口中，点击“安装”按钮开始安装；
8. 等待VMware安装完毕后，在弹出的“安装向导已完成”窗口中，点击“完成”按钮完成安装；
9. 在弹出的“系统重启提示”窗口中，点击“是”按钮重启系统（这里也可以点击“否”按钮，等激活VMware Workstation 14 Pro后再重启。）；
10. 双击桌面上的“VMware Workstation Pro”图标，在弹出的“VMware Workstation 14激活”窗口中，输入许可证（可以在网上搜索实现），然后点击“继续”按钮请求激活；
11. 在弹出的“激活成功”窗口中，点击“完成”按钮完成软件激活；

### vmware配置（参考）：

1. win+R 打开运行对话框输入cmd 回车  键入 netsh winsock reset 命令并执行 之后重启电脑进入BIOS
2. 根据自己的电脑BIOS具体情况配置，将cpu虚拟化功能打开（注：此项因不同电脑差异很大需要自行搜索对应的这是方法）。
3. 下载Ubuntu镜像文件（参考网址：www.ubuntu.com）。
4. 创建虚拟机。
5. 点击“自定义”安装。
6. 硬件兼容性选择“Workstation 14.x”。
7. 点击“稍后安装操作系统”。
8. 客户机操作系统选择“Linux”，版本选择“Ubuntu 64 位”。
9. “虚拟机名称”可以按照你的意愿进行更改，”位置”是我们需要安装的ubuntu操作系统的安装目录。在空间充足的磁盘内部建立一个文件夹即可。
10. 处理器配置采用默认的配置即可。
11. 虚拟机运行需要分配一定大小的内存，这个可根据电脑的配置进行分配。建议不得低于1.5G。
12. 网络连接选择“使用桥接网络”，对于在主机PC同一网段内的IP地址比较充裕的情况下建议选择此连接方式，否则建议选择“使用网络地址转换”模式。具体这三种连接方式的区别请百度自行查看。
13. 一路采用推荐配置直至创建磁盘选项界面，点击“创建新虚拟磁盘”。
14. 磁盘大小可根据需要进行设置，但是建议不要小于20G。然后选择“将虚拟磁盘存储为单个文件”。选择这个的好处是磁盘访问速度比较快，如果选择“将虚拟磁盘拆分为多个文件”访问速度会慢一些，但是磁盘利用率比较高。
15. 磁盘文件名可根据意愿进行修改。
16. 点击“自定义硬件”。
17. 选择“新CD/DVD”选项，然后点击“使用ISO映像文件”，将ISO目录设置为之前下载的ubuntu ISO目录即可，最后点击完成。

### ubuntu18安装步骤参考：

1. 开启电脑或者虚拟机。
2. 选择“中文（简体）”，然后点击“安装Ubuntu”。
3. 键盘布局选择汉语。
4. 更新和其他软件采用默认选项。
5. 安装类型根据具体情况选择清楚整个磁盘安装或者与window共存选项。
6. 根据上面的选择情况设置磁盘选项。
7. 地区可以选择：上海、重庆、乌鲁木齐、香港均可。
8. 设置用户名以及密码，备注此项重要，需要牢记我们设置的用户名或者密码。
9. 继续之后等待安装成功。然后重启电脑或者虚拟机。

### 双系统安装参考

环境准备：

1. 制作ubuntu系统u盘（windows）：

   a）下载制作安装盘的软件 rufus(ps:若是 UEFI 的启动方式，建议使用 rufus 制作安装) 链接：http://rufus.akeo.ie/

   b）在官网下载 18.04 的镜像 iso 到本地； 

   c）打开rufus 选择创建一个启动磁盘（在其后选择ISO镜像）

   d）然后需要根据具体需要，对“分区方案和目标系统类型”进行选择，以下为各选项含义: “MBR分区方案用户BIOS或UEFI的计算机”: 硬盘为MBR分区格式, 则可选择此项,但是如果你有一 个 UEFI 的计算机,最好选择下面之一. “用于 UEFI 计算机的 MBR 分区方案”: 若是 UEFI 方式安装,并且分区格式为 MBR,则选择此项 “用户UEFI计算机的 GPT分区方案”: 若是 UEFI方式安装,且分区格式为GPT, 则选择此项(ps:若是与 win10 共存,则选择此项)

   e）点击开始后，弹出的对话框保持默认即可。

2. 磁盘预留操作：我们右键点击此电脑，然后点击管理就进入了管理。然后点击存储进入磁盘管理。这时候可以看看哪个盘符剩余容量较多，便压缩哪个盘符。推荐给Ubuntu分配60G大小。当然如果硬盘空余较多，也可以给Ubuntu分配更大的空间。压缩完以后我们可以看到有个空余空间，这时候我们不要给它分配盘符，默认这样就行了。

3. 进入BIOS设置U盘启动：根据自己的电脑具体情况而定。

## Linux发展史及主要发行版本

**1．Red Hat Linux**

Red  Hat是一个比较成熟的Linux版本，无论在销售还是装机量上都比较可观。该版本从4.0开始同时支持Intel、Alpha及Sparc硬件平台，并  且通过Red Hat公司的开发使得用户可以轻松地进行软件升级，彻底卸载应用软件和系统部件。Red Hat最早由Bob Young和Marc  Ewing在1995年创建，目前分为两个系列，即由Red Hat公司提供收费技术支持和更新的Red Hat Enterprise  Linux，以及由社区开发的免费的Fedora Core。Fedora Core 1发布于2003年年末，定位为桌面用户。Fedora  Core提供了最新的软件包，同时版本更新周期也非常短，仅6个月。目前最新版本为Fedora Core 6，而Fedora Core  7的测试版已经推出，适用于服务器的版本是Red Hat Enterprise  Linux。由于这是个收费的操作系统，于是国内外许多企业或网络空间公司选择CentOS。CentOS可以算是Red Hat Enterprise  Linux的克隆版，但是免费的，其官方主页是<http://www.redhat.com/>。

**2．Debian Linux**

Debian最早由Ian  Murdock于1993年创建，可以算是迄今为止最遵循GNU规范的Linux系统。Debian系统分为3个版本分支（Branch），即  Stable、Testing和Unstable。截至2005年5月，这3个版本分支分别对应的具体版本为Woody、Sarge和Sid。其  中，Unstable为最新的测试版本，包括最新的软件包。但是也有相对较多的Bug，适合桌面用户Testing的版本都经过Unstable中的测  试，相对较为稳定，也支持了不少新技术（比如SMP等）。而Woody一般只用于服务器，其中的软件包大部分都比较过时，但是稳定性能和安全性能都非常  高，是如此多的用户痴迷于Debian、Apt-Get和Dpkg原因之一。Dpkg是Debian系列特有的软件包管理工具，它被誉为所有Linux软   件包管理工具（比如RPM）中最强大的，配合Apt-Get在Debian上安装、升级、删除和管理软件变得异常容易。许多Debian的用户都开玩笑地  说，Debian将他们养懒了，因为只要输入"Apt-Get Upgrade && Apt-Get  Upgrade"，计算机上所有的软件就会自动更新。其官方主页是<http://www.debian.org/>。

**3．Ubuntu Linux**

简单而言，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强优点的近乎完美的Linux操作系统。Ubuntu是一个相对较新的发  行版，它的出现可能改变了许多潜在用户对Linux的看法。也许，以前人们会认为Linux难以安装并难以使用，但是Ubuntu出现后这些都成为了历  史。Ubuntu基于Debian  Sid，所以拥有Debian的所有优点，包括Apt-Get。然而不仅如此，Ubuntu默认采用的GNOME桌面系统也将Ubuntu的界面装饰得简  易而不失华丽。当然如果你是一个KDE的拥护者的话，Ubuntu同样适合。Ubuntu的安装非常人性化，只要按照提示一步一步进行，安装操作与  Windows操作系统同样简便。并且Ubuntu被誉为是对硬件支持最好最全面的Linux发行版之一，许多在其他发行版上无法使用或者默认配置时无法   使用的硬件，在Ubuntu上可以轻松实现。并且它采用自行加强的内核（Kernel），安全性方面更加完善。Ubuntu默认不能直接Root登录，必   须由第1个创建的用户通过Su或Sudo来获取Root权限（这也许不太方便，但无疑增加了安全性，避免用户由于粗心而损坏系统）。Ubuntu的版本周  期为6个月，弥补了Debian更新缓慢的不足，其官方主页是<http://www.ubuntulinux.org/>。

**4．Slackware Linux**

Slackware由Patrick  Volkerding创建于1992年，应当是历史最悠久的Linux发行版。它曾经非常流行，但是当Linux越来越普及，用户的技术层面越来越广（更   多的新手）后，而渐渐地被新来的人们所遗忘。在其他主流发行版强调易用性时，Slackware依然固执地追求最原始的效率--所有的配置均要通过配置文  件来进行。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的Linux老手）。它稳定且安全，所以仍然有大批的忠实用户。由于  Slackware尽量采用原版的软件包而不进行任何修改，所以制造新Bug的概率便低了很多。其版本更新周期较长（大约1年），但是新版本仍然不间断地  提供给用户下载，其官方主页是<http://www.slackware.com/>。

**5．Suse Linux**

Suse是起源于德国的最著名的Linux发行版，在全世界范围中也享有较高的声誉，其自主开发的软件包管理系统YaST也大受好评。Suse于  2003年年末被Novell收购，Suse  8.0之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其他发行  版本。但是瑕不掩瑜，Suse仍然是一个非常专业且优秀的发行版，其官方主页是<http://www.suse.com/>。

**6．Gentoo Linux**

Gentoo Linux最初由Daniel Robbins（前Stampede  Linux和FreeBSD的开发者之一）创建，由于开发者对FreeBSD的熟识，所以Gentoo拥有媲美FreeBSD的广受美誉的ports系统   --portage（ports和portage都是用于在线更新软件的系统，类似于apt-get，但还是有很大不同）。Gentoo的首个稳定版本发   布于2002年，其出名是因为高度的自定制性，它是一个基于源代码的（source-based）发行版。尽管安装时可以选择预先编译好的软件包，但是大   部分使用用户都选择自己手动编译，这也是为什么Gentoo适合比较有Linux使用经验的老手使用的原因。但是要注意的是，由于编译软件需要消耗大量的  时间，所以如果所有的软件都自己编译并安装KDE桌面系统等比较大的软件包，可能需要几天时间，其官方主页是<http://www.gentoo.org/>。

**7．其他**

Linux世界最不缺乏的可能就是发行版本了，目前全球至少有386个不同的发行版本，了解Linux发行版的最佳方法是查看Linux流行风向标的网站（[www.distrowatch.com](http://www.distrowatch.com/)）。在发行版排行中，目前Ubuntu的发行版高居榜首。

## Ubuntu的图形界面及命令行

按CTRL+ALT+T即可进入终端命令行界面。

常用命令：

ls  查看目录
which  python3   查看python命令的路径
cd  目录 ，  切换到指定的目录
ip  addr  查看本机的ip地址
ping ip  尝试 ping 目标机的ip， 是否连接
pwd 显示当前目录
tar -xvf  xxx.tar  解压 *.tar.gz 压缩文件
man  命令  查看命令说明文档，   W｜U 向上一页， D 向下一页， J 向下一行， K向上一行， G 首行，B 回退上一次位置， Q 退出
win + space      空格  ：   英文 和 中文 切换 

## 系统目录介绍

常用的目录

​    / 根目录

​    /home 所有用户的家目录

​    /root   root用户家目录

​    /boot   存放Linux系统启动时需要加载的文件。 grub2   kernel 

​    /usr/bin  用户安装的可执行的系统程序

​    /usr/local/bin 本地用户安装的应用程序

​    /etc  系统配置信息

​    /proc 系统进程信息

​    /media 挂载的外部媒体（中介： cdrom/usb/dvd/磁盘）

​    /mnt  针对media的媒体， 在挂载时可用的目录

​    /tmp  临时文件目录

​    /var  软件数据默认目录

## Ubuntu下的包管理
### 修改境内仓库源

修改阿里源为Ubuntu 18.04默认的源

备份/etc/apt/sources.list
```
#备份
cp /etc/apt/sources.list /etc/apt/sources.list.bak
```
在/etc/apt/sources.list文件前面添加如下条目
```
#添加阿里源
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
```
最后执行如下命令更新源
```
#更新
sudo apt-get update
sudo apt-get upgrade
```
另外其他几个国内源如下：
中科大源
```
#中科大源
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
```
163源
```
#163源
deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse
```
清华源
```
#清华源
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
```


### apt-get命令的常用子命令

| update  | 更新软件包列表         |
| ------- | ---------------------- |
| upgrade | 升级系统中的所有软件包 |
| install | 安装软件包             |
| remove  | 卸载软件包             |
|clean|删除本地缓存的所有升级包|
示例：

$ sudo apt-get install python3-devel



# 第二天：文件系统与用户管理

**命令格式：**命令 选项 参数

**参数用法：**选项作用是调用命令的具体功能，单个字符-，多个字符--，单个字符可合并去写。参数指操作对象。选项和参数可调换位置。

## 文件与目录的管理

### 文件路径符号：

|符号|/|.|..|~|-|
|--|--|--|--|--|--|
|意义|根|当前|上一级|家目录|上一次|

### 目录操作命令
|命令|格式|常用参数及解释|
|--|----|------------|
|ls (列出目录)|ls [-aAdfFhilnrRSt] 目录名称|-a  ：全部的文件。  -d  ：仅列出目录本身 -l  ：长格式列出(常用)。-i: 显示文件的索引号。－F ：显示路径。|
|cd (切换目录)|cd [相对路径或绝对路径]||
|pwd (显示当前所在的目录)|pwd||
|mkdir (创建新目录)|mkdir [-mp] 目录名称|-m ：配置文件的权限 。 -p:递归创建|
|rmdir (删除空的目录)|rmdir  目录名称||
|cp (复制文件或目录)|cp [-adfilprsu] 来源档(source) 目标档(destination)|-p：连同文件的属性一起复制过去。-r：递归持续复制。-i：交互模式|
|rm (移除文件或目录)|rm [-fir] 文件或目录|-f  ：非交互模式。-i  ：互动模式。-r  ：递归删除啊。|
|mv (移动文件与目录，或修改名称)|mv [-fiu] source destination|-f  ：force 强制的意思，非交互。-i  ：交互模式。-u  ：若目标文件已经存在，且 source 比较新，才会升级 (update)|

### 文件操作命令
|命令|格式|常用参数及解释|
|--|----|------------|
|rm (移除文件或目录)|rm [-fir] 文件或目录|-f  ：非交互模式。-i  ：互动模式。-r  ：递归删除啊。|
|mv (移动文件与目录，或修改名称)|mv [-fiu] source destination|-f  ：force 强制的意思，非交互。-i  ：交互模式。-u  ：若目标文件已经存在，且 source 比较新，才会升级 (update)|
|cp (复制文件或目录)|cp [-adfilprsu] 来源档(source) 目标档(destination)|-p：连同文件的属性一起复制过去。-r：递归持续复制。-i：交互模式|
|touch(创建文件)|touch filepath-name||
|find(查找文件)|find [查找路径] 查找条件 [查找后执行的动作]|参数参考附录部分|
|xargs（给命令传递参数进行过滤）|somecommand \|xargs -item  command|-a file 从文件中读入作为sdtin。-e flag   flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p  交互执行命令。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-d delim 分隔符，默认的xargs分隔符是回车。|
|tar(用来建立，还原备份文件)|tar [-cxrzjvf] test.tar.gz a.c|-f  备份文件。-C  目的目录。-c 建立新的备份文件。-x 从备份文件中还原文件。-z  通过gzip指令处理备份文件。-j  通过bz2指令处理备份文件。-v   显示指令执行过程。-O：将文件解开到标准输出。-r 是表示增加文件的意思。|

备注：-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 

## 用户管理

用户管理相关配置文件

/etc/passwd  存放用户基本信息

/etc/shadow   存放用户的密码信息，包含加密后的密码和密码策略。

/etc/group   存放组基本信息。

/etc/gshadow   存放组的密码信息

/etc/login.defs   存放密码的默认策略和UID/GID范围等信息

/etc/default/useradd   添加用户的默认设置

/etc/skel/   用户家目录的模板文件

/etc/sudoers  用户权限配置文件

**添加新的用户（useradd）：** 

```
useradd 选项 用户名
```

参数说明：

-  选项: 
  - -c comment 指定一段注释性描述。
  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  - -g 用户组 指定用户所属的用户组。
  - -G 用户组，用户组 指定用户所属的附加组。
  - -s Shell文件 指定用户的登录Shell。
  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

**删除帐号(userdel)**

```
userdel 选项 用户名
```

 常用的选项是 -r，它的作用是把用户的主目录一起删除。

**修改帐号(usermod)** 

 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 

 修改已有用户的信息使用`usermod`命令，其格式如下： 

```
usermod 选项 用户名
```

常用的选项包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样，-l 新用户名 

**用户口令的管理(passwd)**

指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为： 

```
passwd 选项 用户名
```

 可使用的选项： 

- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

**新建用户组(groupadd)：**

```
groupadd 选项 用户组
```

可以使用的选项有：

- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

实例1：

```
# groupadd group1
```

 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 

实例2：

```
# groupadd -g 101 group2
```

 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

**删除用户组（groupdel）：**

```
groupdel 用户组
```

例如：

```
# groupdel group1
```

此命令从系统中删除组group1。

**修改用户组属性（groupmod命令）**

```
groupmod 选项 用户组
```

常用的选项有： 

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

实例1：

```
# groupmod -g 102 group2
```

此命令将组group2的组标识号修改为102。 

实例2：

```
# groupmod –g 10000 -n group3 group2
```

 此命令将组group2的标识号改为10000，组名修改为group3。

**切换用户到其他组（newgrp）**

用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

```
$ newgrp root
```

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。 

## 用户相关命令：

chage -l username 罗列用户的密码策略 

chage username  修改用户的密码策略

su 切换用户

id 查看用户UID/组ID/所属组等信息

who 查看当前系统中哪些用户在登录

whoami 查看当前你登录的是谁

sudo 临时获取sudoers权限

### 扩展：sudoers配置说明

​	sodu  普通用户临时获取root权限

​	用法示例：sodu useradd xxg

​	visudo  可以通过命令修改/etc/sudoers授予用户的sodu管理员权限

```shell
###/etc/sudoers文件注解：
#定义用户别名SYSADER 下有成员 beinan、linuxsir和beinan用户组下的成员，用户组前面必须加%号
User_Alias SYSADER=beinan,linuxsir,%beinan 

#定义用户别名 DISKADER ，成员有lanhaitun 
User_Alias DISKADER=lanhaitun 

#定义Runas用户，也就是目标用户的别名为OP，下有成员root
Runas_Alias OP=root 

#定义SYSCMD命令别名，成员之间用,号分隔，最后的!/usr/bin/passwd root 表示不能通过passwd 来更改root密码
Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd root（注意这里的！）

#定义命令别名DSKCMD，下有成员parted和fdisk 
Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk 注：定义命令别名DSKCMD，下有成员parted和fdisk ；

#表示授权SYSADER下的任何成员，在任何可能存在的主机名的主机下运行或禁止 SYDCMD和DSKCMD下定义的命令。 更为明确遥说，beinan、linuxsir和beinan用户组下的成员能以root身份运行 chown 、chmod 、adduser、passwd，但不能更改root的密码； 也能够以root身份运行 parted和fdisk ， 本条规则的等价规则是； beinan,linuxsir,%beinan ALL=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd root,/sbin/parted,/sbin/fdisk 
SYSADER ALL= SYDCMD,DSKCMD 

#表示授权DISKADER 下的任何成员，能以OP的身份，来运行 DSKCMD ，无需密码；更为明确的说 lanhaitun 能以root身份运行 parted和fdisk 命令；其等价规则是： lanhaitun ALL=(root) /sbin/parted,/sbin/fdisk
DISKADER ALL= (OP) DSKCMD
```

## ugo权限操作指令

ls -l  查看文件基础权限     

```
#查看文件的UGO权限。各项意义说明
	第一列内容的第一个字符代表文件类型。
		-普通文件 ，
		d目录文件，
		l链接文件，
		s套接字文件，
		c字符设备文件，
		b块设备文件，
		p管道文件
	第一列内容的第2-10字符代表文件的ugo权限。
	U代表文件的拥有者段，从第二位到第四位
	G代表文件的所属组的段，从第五位到第七位
	O代表其他人的段，从第八位到第十位
	权限说明：
	对于文件：r代表可使用cat等命令查看文件内容，w代表可增 加/删除/修改文件内容，x代表可执行该文件。
	对于目录：r代表可使用ls命令列出目录下的文件名，要想看文件的详细信息，需结合x权限。w代表表可在该目录下创建/删除文件和子目录，或修改 文件名称， 要与x结合使用。x代表可进入该目录。 
	ll  等价于ls –l命令
```

chown 切换文件所示用户

```
有以下格式：
1. chown username file   #将file的所属用户修改为username
2. chown username.|: file #将file的所属组以及用户全部修改为username
3. chown .|:username file #将file的所属组修改为username
4. chown username.|:groupname #将file的所属用户修改为username，所属组修改为groupname
#备注：
1）.|:代表.或者：
2）加上-R参数代表修改该目录下的所有文件（递归）
```

chmod  修改用户基础权限

```
有以下格式
1. chmod [ugoa][+-][rwx] file #在file的指定权限段上附加或减去指定权限
2. chmod nnn file #以数字形式直接指定file的权限模型
备注：
n为0-7中的任意数字，三个n分别代表ugo三个权限段的值。数字计算规则为r=4、w=2，x=1,每段权限之和为n
```

## 扩展（批量添加用户）

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

（1）先编辑一个文本用户文件。

每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：

```
user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
user004::603:100:user:/home/user004:/bin/bash
user005::604:100:user:/home/user005:/bin/bash
user006::605:100:user:/home/user006:/bin/bash
```

（2）以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户：

```
# newusers < user.txt
```

然后可以执行命令 `vipw` 或 `vi /etc/passwd` 检查 `/etc/passwd` 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

（3）执行命令/usr/sbin/pwunconv。

将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到 `/etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。

```
# pwunconv
```

（4）编辑每个用户的密码对照文件。

范例文件 `passwd.txt` 内容如下：

```
user001:密码
user002:密码
user003:密码
user004:密码
user005:密码
user006:密码
```

（5）以root身份执行命令 `/usr/sbin/chpasswd`。

创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。

```
# chpasswd < passwd.txt
```

（6）确定密码经编码写入/etc/passwd的密码栏后。

执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。

```
# pwconv
```

这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。

# 第三天：文本操作

## 文本内容查看

|命令（说明）|格式|常用参数|
|----|----|----|
|cat(连接文件并打印到标准输出设备）|cat -[nbs] fileName|-n 或 --number：由 1 开始对所有输出的行数编号。-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。|
|head(用来显示档案的开头至标准输出中)||-c<数目> 显示的字节数。-n<行数> 显示行数。|
|tail（用来显示档案的尾部至标准输出中)||-c<数目> 显示的字节数。-n<行数> 显示行数。-f 循环读取。默认读取10行|
|less（逐页阅读）||**全屏导航**
ctrl + F - 向前移动一屏
ctrl + B - 向后移动一屏
ctrl + D - 向前移动半屏
ctrl + U - 向后移动半屏
**单行导航**
j - 向前移动一行
k - 向后移动一行
**其它导航**
G - 移动到最后一行
g - 移动到第一行
q / ZZ - 退出 less 命令|
|more（逐页阅读）||常用操作命令：<br/>Enter    向下n行，需要定义。默认为1行
Ctrl+F   向下滚动一屏
空格键  向下滚动一屏
Ctrl+B  返回上一屏
=       输出当前行的行号
：f     输出文件名和当前行的行号
V      调用vi编辑器
!命令   调用Shell，并执行命令 
q       退出more|
|sed（利用script来处理文本文件）|sed \[-hnV\]\[-e\<script\>\]\[-f\<script文件\>\]\[文本文件\]|-e：直接在命令列模式上进行 sed 的动作编辑。<br />-n：则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
-f：直接将 sed 的动作写在一个文件内。<br />-i∶直接修改读取的文本内容<br />**动作说明：**
​    a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
​    c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
​    d ：删除，因为是删除啊，所以 d 后面通常不接任何内容；
​    i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
​    p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
​    s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！<br />**使用详情：**参考网页https://www.jb51.net/article/111306.htm|
|echo(显示一段文字)|echo \[-ne\]\[字符串\]|-n 表示不换行。-e 表示对转义字符进行特殊处理。|
|diff (比较文件的差异)|diff -option file1 file2|-B或--ignore-blank-lines 　不检查空白行。-c 　显示全部内文，并标出不同之处。-i或--ignore-case 　不检查大小写的不同。-w或--ignore-all-space 　忽略全部的空格字符。-y或--side-by-side 　以并列的方式显示文件的异同之处。|
|cut（文档切割显示）|cut \[选项\]\[参数\]|-b：仅显示行中指定直接（字节）范围的内容； <br />-c：仅显示行中指定（字符）范围的字符； <br />-d：指定字段的分隔符，默认的字段分隔符为“TAB”； <br />-f：显示指定字段的内容；  <br />-n：与“-b”选项连用，不分割多字节字符；|
|awk（文档按行编辑）|awk [选项参数] 'script' var=value file(s)|详细参见awk编辑器md文档|
|grep（从文件）|grep \[-acinv\]\[--color=auto\] '搜寻字符串' filename|-a ：将 binary 文件以 text 文件的方式搜寻数据 <br />-c ：计算找到 '搜寻字符串' 的次数 <br />-i ：忽略大小写的不同，所以大小写视为相同 <br />-n ：顺便输出行号<br /> -v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！ <br />--color=auto ：可以将找到的关键词部分加上颜色|
|sort（将文本文件内容加以排序）|sort \[-bcdfimMnr\]\[-o<输出文件>\]\[-t<分隔字符>\]\[+<起始栏位>-<结束栏位>\]\[--help\]\[--verison\]\[文件\]| --b   忽略每行前面开始出的空格字符。 <br />-c   检查文件是否已经按照顺序排序。 <br />-d   排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 <br />-f   排序时，将小写字母视为大写字母。 <br />-i   排序时，除了040至176之间的ASCII字符外，忽略其他的字符。 <br />-m   将几个排序好的文件进行合并。 <br />-M   将前面3个字母依照月份的缩写进行排序。 <br />-n   依照数值的大小排序。 <br />-o<输出文件>   将排序后的结果存入指定的文件。 <br />-r   以相反的顺序来排序。 <br />-u 输出行中去除重复行<br />-t<分隔字符>   指定排序时所用的栏位分隔字符。 <br />+<起始栏位>-<结束栏位>   以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 <br />--help   显示帮助。 --version   显示版本信息。 |
|uniq（过滤相邻的重复行）|uniq \[-cdu\]\[-f<栏位>\]\[-s<字符位置>\]\[-w<字符位置>\]\[--help\]\[--version\]\[输入文件\]\[输出文件\]|-c或--count   在每列旁边显示该行重复出现的次数。<br />-d或--repeated   仅显示重复出现的行列。<br />-u或--unique   仅显示出一次的行列。<br />-w<字符位置>或--check-chars=<字符位置>   指定要比较的字符。<br />-f<栏位>或--skip-fields=<栏位>   忽略比较指定的栏位。|

sed应用示例：

```shell
#将第2-5行的内容取代成为『No 2-5 number』
$ nl /etc/passwd | sed '2,5c No 2-5 number'
1 root:x:0:0:root:/root:/bin/bash
No 2-5 number
6 sync:x:5:0:sync:/sbin:/bin/sync
.....(后面省略).....

#仅列出 /etc/passwd 文件内的第 5-7 行
[root@www ~]# nl /etc/passwd | sed -n '5,7p'
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown

#删除/etc/passwd所有包含root的行，其他行输出
$nl /etc/passwd | sed  '/root/d'
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
.....(后面省略).....
```

awk应用示例：

```shell
 过滤第一列大于2的行

$ awk '$1>2' log.txt    #命令
#输出
3 Are you like awk
This's a test
10 There are orange,apple,mongo

过滤第一列等于2的行

$ awk '$1==2 {print $1,$3}' log.txt    #命令
#输出
2 is

过滤第一列大于2并且第二列等于'Are'的行

$ awk '$1>2 && $2=="Are" {print $1,$2,$3}' log.txt    #命令
#输出
3 Are you
```



## 管道符、重定向

**管道符：**| 用来连接两条命令，将上一条命令的输出作为下一条命令的输入。

**重定向:**

```
#输出重定向
command [OPTION]{>,>>} [File]
```

\>或者着>> 将符号之前的命令的结果输出至富豪之后的文件中 >为覆盖 >> 为追加

```
#输入重定向
 command {<} [File] {<<} [Word]
```
这里的 < 与 << 意义不是类似于输出重定向的操作符，< 是从文件中取出数据到指定的文件中
<<后面的Word为输入结束标记	

## 文本编辑器 sed

sed 是一个比较古老的，功能十分强大的用于文本处理的流编辑器，加上正则表达式的支持，可以进行大量的复杂的文本编辑操作。sed 本身是一个非常复杂的工具，有专门的书籍讲解 sed 的具体用法，但是个人觉得没有必要去学习它的每个细节，那样没有特别大的实际意义。

## 文本编辑器Vi/Vim

### **第一级命令（能用级别）:**

安装好一个编辑器后，我们一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：

- 启 动Vim后，vim在 *Normal* 模式下。
- 让我们进入 *Insert* 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）
- 此时，你可以输入文本了，就像你用“记事本”一样。
- 如果你想返回 *Normal* 模式，请按 `ESC` 键。

现在，你知道如何在 *Insert* 和 *Normal* 模式下切换了。下面是一些命令，可以让你在 *Normal* 模式下幸存下来：

> - `i` → *Insert* 模式，按 `ESC` 回到 *Normal* 模式.
> - `x` → 删当前光标所在的一个字符。
> - `:wq` → 存盘 + 退出 (`:w` 存盘, `:q` 退出)   （陈皓注：:w 后可以跟文件名）
> - `dd` → 删除当前行，并把删除的行存到剪贴板里
> - `p` → 粘贴剪贴板
>
> **推荐**:
>
> - `hjkl` (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: `j` 就像下箭头。
> - `:help <command>` → 显示相关命令的帮助。你也可以就输入 `:help` 而不跟命令。（陈皓注：退出帮助需要输入:q）

### 第二级命令（编辑进阶）

上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）

1. 各种插入模式

   > - `a` → 在光标后插入
   > - `o` → 在当前行后插入一个新行
   > - `O` → 在当前行前插入一个新行
   > - `cw` → 替换从光标所在位置后到一个单词结尾的字符

2. 简单的移动光标

   > - `0` → 数字零，到行头
   > - `^` → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）
   > - `$` → 到本行行尾
   > - `g_` → 到本行最后一个不是blank字符的位置。
   > - `/pattern` → 搜索 `pattern` 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）

3. 拷贝/粘贴

    （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）

   > - `P` → 粘贴
   > - `yy` → 拷贝当前行当行于 `ddP`

4. Undo/Redo

   > - `u` → undo
   > - `<C-r>` → redo

5. 打开/保存/退出/改变文件

   (Buffer)

   > - `:e <path/to/file>` → 打开一个文件
   > - `:w` → 存盘
   > - `:saveas <path/to/file>` → 另存为 `<path/to/file>`
   > - `:x`， `ZZ` 或 `:wq` → 保存并退出 (`:x` 表示仅在需要时保存，ZZ不需要输入冒号并回车)
   > - `:q!` → 退出不保存 `:qa!` 强行退出所有的正在编辑的文件，就算别的文件有更改。
   > - `:bn` 和 `:bp` → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）

花点时间熟悉一下上面的命令，一旦我们掌握他们了，就几乎可以干其它编辑器都能干的事了。

#### 第三级命令（更好，更强，更快）

先恭喜你！干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。

##### 更好

下面，让我们看一下vim是怎么重复自己的：

1. `.` → (小数点) 可以重复上一次的命令
2. N<command> → 重复某个命令N次

下面是一个示例，找开一个文件你可以试试下面的命令：

> - `2dd` → 删除2行
> - `3p` → 粘贴文本3次
> - `100idesu [ESC]` → 会写下 “desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu desu desu desu desu  desu desu desu desu desu desu desu desu desu desu “
> - `.` → 重复上一个命令—— 100 “desu “.
> - `3.` → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).

##### 更强

你要让你的光标移动更有效率，你一定要了解下面的这些命令，**千万别跳过**。

1. N`G` → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）

2. `gg` → 到第一行。（陈皓注：相当于1G，或 :1）

3. `G` → 到最后一行。

4. 按单词移动：

   > 1. `w` → 到下一个单词的开头。
   > 2. `e` → 到下一个单词的结尾。
   >
   > \> 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）
   >
   > \> 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）
   >
   > ![Word moves example](第五周新版.assets/word_moves.jpg)

下面，让我来说说最强的光标移动：

> - `%` : 匹配括号移动，包括 `(`, `{`, `[`. （陈皓注：你需要把光标先移到括号上）
> - `*` 和 `#`:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）

相信我，上面这三个命令对程序员来说是相当强大的。

##### 更快

你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：

```
<start position><command><end position>
```

例如 `0y$` 命令意味着：

- `0` → 先到行头
- `y` → 从这里开始拷贝
- `$` → 拷贝到本行最后一个字符

你可可以输入 `ye`，从当前位置拷贝到本单词的最后一个字符。

你也可以输入 `y2/foo` 来拷贝2个 “foo” 之间的字符串。

还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：

- `d` (删除 )
- `v` (可视化的选择)
- `gU` (变大写)
- `gu` (变小写)

#### 第四级命令 （ Vim 超能力）

介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。

**在当前行上移动光标: `0` `^` `#####  `f` `F` `t` `T` `,` `;`**

> - `0` → 到行头
> - `^` → 到本行的第一个非blank字符
> - `$` → 到行尾
> - `g_` → 到本行最后一个不是blank字符的位置。
> - `fa` → 到下一个为a的字符处，我们也可以fs到下一个为s的字符。
> - `t,` → 到逗号前的第一个字符。逗号可以变成其它字符。
> - `3fa` → 在当前行查找第三个出现的a。
> - `F` 和 `T` → 和 `f` 和 `t` 一样，只不过是相反方向。

**区域选择 `<action>a<object>` 或 `<action>i<object>**`

在visual 模式下，这些命令很强大，其命令格式为

```
<action>a<object>` 和 `<action>i<object>
```

- action可以是任何的命令，如 `d` (删除), `y` (拷贝), `v` (可以视模式选择)。
- object 可能是： `w` 一个单词， `W` 一个以空格为分隔的单词， `s` 一个句字， `p` 一个段落。也可以是一个特别的字符：`"、` `'、` `)、` `}、` `]。`

假设你有一个字符串 `(map (+) ("foo"))`.而光标键在第一个 `o `的位置。

> - `vi"` → 会选择 `foo`.
> - `va"` → 会选择 `"foo"`.
> - `vi)` → 会选择 `"foo"`.
> - `va)` → 会选择`("foo")`.
> - `v2i)` → 会选择 `map (+) ("foo")`
> - `v2a)` → 会选择 `(map (+) ("foo"))`

**块操作: `<C-v>`**

块操作，典型的操作： `0 <C-v> <C-d> I-- [ESC]`

- `^` → 到行头
- `<C-v>` → 开始块操作
- `<C-d>` → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)
- `I-- [ESC]` → I是插入，插入“`--`”，按ESC键来为每一行生效。

**自动提示： `<C-n>` 和 `<C-p>**`

在 Insert 模式下，你可以输入一个词的开头，然后按 `<C-p>或是<C-n>，自动补齐功能就出现了……`

**宏录制： `qa` 操作序列 `q`, `@a`, `@@**`

- `qa` 把你的操作记录在寄存器 `a。`
- 于是 `@a` 会replay被录制的宏。
- `@@` 是一个快捷键用来replay最新录制的宏。

> **示例**
>
> 在一个只有一行且这一行只有“1”的文本中，键入如下命令：
>
> - ```
>   qaYp<C-a>q
>   ```
>
>   → 
>
>   - `qa` 开始录制
>   - `Yp` 复制行.
>   - `<C-a>` 增加1.
>   - `q` 停止录制.
>
> - `@a` → 在1下面写下 2
>
> - `@@` → 在2 正面写下3
>
> - 现在做 `100@@` 会创建新的100行，并把数据增加到 103.



# 第四天：网络命令、进程管理与服务配置

## 网络管理命令

1、ip查看命令
ifconfig命令：查看与配置网络状态命令 （看不到网关）
ip addr命令 ：查看网卡配置信息

2、关闭与启动网卡
fdown  网卡设备名	#禁用该网卡设备
ifup  网卡设备名		#启用该网卡设备

3、查询网络状态
netstat  选项
选项：
​	-t：列出TCP协议端口
​	-u：列出UDP协议端口
​	-n：不使用域名与服务名，而使用IP地址和端口号
​	-l ：仅列出在监听状态网络服务（只有TCP有监听状态）
​	-a：列出所有网络连接
​	-r ：列出路由列表，功能和route命令一致
4、查看网关
netstat  -rn
route  -n
5、查看DNS
nslookup命令：用来翻译域名对应哪个IP
（1）：nslookup  [主机名或IP] #进行域名与IP地址解析
（2）：nslookup  #查看本机DNS服务器
6、网络测试命令
​	1、ping命令
​		格式：ping  [选项]  ip或域名#探测指定IP或域名的网络状况
​		选项：-c：次数：指定ping包的次数
​	2、telnet命令
​		格式：telnet  [域名或者IP][端口]# 远程管理与端口探测命令
​	3、trceroute命令
​		格式：traceroute  [选项]  IP或域名# 路由跟踪命令
​		选项：-n：使用IP，不使用域名，速度更快
​	4、wget命令
​		格式：wget http://soft.vpser.net/lnmp1.1-full.tar.gz# 下载命令

7、ssh 远程登录命令

常用格式：ssh -l login_name [user@]hostname

8、远程复制命令scp

>1．命令格式：
>scp [参数] [原路径] [目标路径]
>
>2．命令功能：
>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。
>
>3．命令参数：
>```
>-1  强制scp命令使用协议ssh1  
>-2  强制scp命令使用协议ssh2  
>-4  强制scp命令只使用IPv4寻址  
>-6  强制scp命令只使用IPv6寻址  
>-B  使用批处理模式（传输过程中不询问传输口令或短语）  
>-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  
>-p 保留原文件的修改时间，访问时间和访问权限。  
>-q  不显示传输进度条。  
>-r  递归复制整个目录。  
>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   
>-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   
>-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  
>-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    
>-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     
>-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   
>-P port  注意是大写的P, port是指定数据传输用到的端口号   
>-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
>```

进程管理命令：

**ps**

ps 一般情况下我们都使用　aux这三个选项结合来查看进程

ps命令参数

> -a 显示所有用户的所有进程（包括其它用户）；
> -u 按用户名和启动时间的顺序来显示进程；
> -x 显示无控制终端的进程；
> -f 用树形格式来显示进程；
> -r 显示运行中的进程；
> -ef   aux 为常用组合 

显示内容详解

>user:该进成属于什么用户
>PID:进程号
>%CPU:该进程占的CPU的使用率
>%MEM：该进程占的物理内存的百分比
>VSZ:占用的虚拟内存大小，以KB为单位
>RSS:占用的物理内存大小
>TTY:是否为登入着执行的程序，若为tty1-tty6，本机登录．pts/??远程登录
>STAT 进程状态:
>>R    正在运行可中在队列中可过行的；
>>S    处于休眠状态；
>>Z    僵尸进程；
>><    优先级高的进程
>>N    优先级较低的进程
>>s    进程的领导者（在它之下有子进程）；
>>l    多线程
>>
>>+   位于后台的进程组；
>
>Start:这个进程开始的时间
>time:这个进程的运行时间
>command:这个进程的实际内容

**pgrep** 

>>pgrep “init” 查看系统初始化进程init的PID
>
>-l 列出程序名和进程ID；
>
>>pgrep -l “log”进程名中包含log的进程的PID号，同时列出对应的进程名
>
>-U　指定由哪个用户产生的进程
>-t　再哪个tty终端上
>
>>pgrep -l -U student -t tty1
>
>pidof ping  查看指定进程对应的pid

**TOP　动态查看进程**

>按空格space立即更新；
>
>>该命令可以按CPU使用／内存使用和执行时间对任务进行排序
>
>Ｐ键根据cpu占用情况对进程进行排序
>Ｍ键根据内存占用情况排序
>Ｎ键根据启动时间进行排序
>n 提示显示的进程数，比如输入3，就在整屏上显示3个进程；
>c 切换到命令名显示，或显示整个命令（包括参数）
>k 提示输入要杀死的进程ID，目的是用来杀死该进程（默人信号为15）

kill|kill	用以关闭进程
>
>>示例：kill   [signal]   pid
>
>kill   [signal]   进程名
>
>>>1信号，sinhup，一个reload信号，重置信号，让服务重新加载自己的配置文件，让进程重新加载自己的信息包括配置文件，一般用来干嘛，服务器7*24小时运行，不能停，修改了配置文件后，不会立即生效，需要重启才能生效，对于服务器不实际，可以给服务进程发送1信号，在不重启的情况下，让配置立即生效。
>>>2信号 中断进程  相当于 ctrl+c 。
>>>9信号，强制关闭某个进程。
>>>15信号，等待程序正常退出信号，和9的区别是，在于数据流，强制关闭，数据可能没来得及写回硬盘，数据可能丢失，15会等到数据写回，再关闭，Linux中5分钟写回硬盘一次，所以Linux比较快，window实时处理，所以慢

系统管理员若想知道某一时刻用户的行为，只需要输入命令W 即可，

踢掉一个从某个终端连上的用户pkill -kill  -t pts/0

**查看占用指定端口的进程**

> lsof -i :22 

## 系统目录

1. /：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。
2. /bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。
3. /boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。
4. /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。
5. /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。
6. /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。
7. /lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。
8. /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。
9. /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。
10. /opt：给主机额外安装软件所摆放的目录。
11. /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。
12. /root：系统管理员root的家目录。
13. /sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能"查看"而不能设置和使用。
    /14. tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。
14. /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。
15. /usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。
16. /var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。
## LINUX启动登录流程

**启动流程**

1）开机BIOS自检，加载硬盘。
2）读取MBR,进行MBR引导。
3）grub引导菜单(Boot Loader)。
4）加载内核kernel。
5）启动init进程，依据inittab文件设定运行级别

> Linux预置七种init运行级别（0-6）：
> 0：关机模式    （相当于poweroff）
> 1：单用户模式（破解root密码的方法：[linux系统root密码遗忘的情况下的解决办法](http://www.cnblogs.com/kevingrace/p/5798476.html)）
> 2：无网络支持的多用户模式
> 3：有网络支持的多用户模式（也就是文本模式，工作中最常用的模式）
> 4：保留，未使用
> 5：有网络支持的X-windows支持多用户模式（也就是桌面图形模式）
> 6: 重新引导系统，即重启    （相当于reboot）>

6）init进程，执行rc.sysinit文件。
7）启动内核模块，执行不同级别的脚本程序。
8）执行/etc/rc.d/rc.local
9）启动mingetty，进入系统登陆界面。

**登录流程：**

```mermaid
graph TB
    A((login shell))
    B((nologin shell))
    C>/etc/profile]
    D>-/.bash_profile]
    E((开始操作bash))
    F>-/.bashrc]
    G>/etc/.bashrc]
    H>/etc/inputrc]
    I>/etc/profile.d/*sh]
    J>/etc/sysconfig/i18n]
    A==>C
    C-.->H
    C-.->I
    I-.->J
    C==>D
    D-..login_profile.->F
    D-..profile.->F
    F-.->G
    D==>E
    B==>F
```



## 服务管理

Linux 服务管理两种方式service和systemctl

1.service命令
 service命令其实是去/etc/init.d目录下，去执行相关程序

```shell
# service命令启动redis脚本
service redis start
```

其中脚本需要我们自己编写

2.systemctl命令
 systemd是Linux系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。
 systemd对应的进程管理命令是systemctl

1)systemctl命令兼容了service
 即systemctl也会去/etc/init.d目录下，查看，执行相关程序

```shell
systemctl redis start
systemctl redis stop
# 开机自启动
systemctl enable redis
```

chkconfig、service命令与systemctl命令的区别见下表： 
 `注：httpd.service可以简写成httpd` 例如： 
 systemctl status httpd

| 任务                 | 旧指令                       | 新指令                                                 |
| -------------------- | ---------------------------- | ------------------------------------------------------ |
| 使某服务自动启动     | chkconfig –level 3 httpd on  | systemctl enable httpd.service                         |
| 使某服务不自动启动   | chkconfig –level 3 httpd off | systemctl disable httpd.service                        |
| 检查服务状态         | service httpd status         | systemctl status httpd.service （服务详细信息）        |
|                      |                              | systemctl is-active httpd.service （仅显示是否 Active) |
| 加入自定义服务       | chkconfig –add  test         | systemctl  load test.service                           |
| 删除服务             | chkconfig –del  xxx          | 停掉应用，删除相应的配置文件                           |
| 显示所有已启动的服务 | chkconfig –list              | systemctl list-units –type=service                     |
| 启动某服务           | service httpd start          | systemctl start httpd.service                          |
| 停止某服务           | service httpd stop           | systemctl stop httpd.service                           |
| 重启某服务           | service httpd restart        | systemctl restart httpd.service                        |

## IP配置

**临时 配置 ip**

使用命令来执行 ifconfig eth0 192.168.0.1(自己要设置的IP)这个命令是更改主机IP，回车后你什么都看不到，就表示成功了，但是此命令所做的更改在下次重启后就会失效。

ifconfig eth0 network 255.255.255.0(自己设置的子网掩码）该命令是设置主机的子网掩码，所做的设置也是临时的。

**配置 静态 ip**

配置网络需要的文件 ifcfg-eth0文件 路径：eth/sysconfig/network-scripts/ifcfg-eth0
ifcfg-eth0文件配置解析：

```
TYPE=Ethernet  
DEVICE=eth0  
BOOTPROTO=none  
ONBOOT=yes  
IPADDR=10.0.1.27  
NETMASK=255.255.255.0  
GATEWAY=10.0.1.1  
BROADCAST=10.10.1.255  
HWADDR=00:0C:29:13:5D:74（硬件地址：ether f8:a9:63:4d:51:bc  txqueuelen                           1000  (以太网)）  
PEERDNS=yes  
DNS1=10.0.1.41  
USERCTL=no  
NM_CONTROLLED=no  
IPV6INIT=yes  
IPV6ADDR=FD55:faaf:e1ab:1B0D:10:14:24:106/64  
```

1. **配置参数说明**
    注：这些参数值不区分大小写，不区分单引号和双引号，甚至可以不用引号。
>TYPE：配置文件接口类型。在/etc/sysconfig/network-scripts/目录有多种网络配置文件，有Ethernet 、IPsec等类型，网络接口类型为Ethernet。
>DEVICE：网络接口名称
>BOOTPROTO：系统启动地址协议
>
>>none：不使用启动地址协议
>>bootp：BOOTP协议
>>dhcp：DHCP动态地址协议
>>static：静态地址协议
>
>ONBOOT：系统启动时是否激活
>>yes：系统启动时激活该网络接口
>>no：系统启动时不激活该网络接口
>
>IPADDR：IP地址
>NETMASK：子网掩码
>GATEWAY：网关地址
>BROADCAST：广播地址
>HWADDR/MACADDR：MAC地址。只需设置其中一个，同时设置时不能相互冲突。
>PEERDNS：是否指定DNS。如果使用DHCP协议，默认为yes。
>
>>yes：如果DNS设置，修改/etc/resolv.conf中的DNS
>>no：不修改/etc/resolv.conf中的DNS
>
>DNS{1, 2}：DNS地址。当PEERDNS为yes时会被写入/etc/resolv.conf中。
>NM_CONTROLLED：是否由Network  Manager控制该网络接口。修改保存后立即生效，无需重启。被其坑过几次，建议一般设为no。 yes：由Network Manager控制。no：不由Network Manager控制
>USERCTL：用户权限控制
>
>>yes：非root用户允许控制该网络接口
>>no：非root用户不运行控制该网络接口
>
>IPV6INIT：是否执行IPv6
>>yes：支持IPv6
>>no：不支持IPv6
>
>IPV6ADDR：IPv6地址/前缀长度

2. **配置生效**
   为了使网络配置永久有效，就需要在/etc/sysconfig/network-scripts/下修改网络接口配置文件。但是，这些文件修改后，并不能立即生效。有两种方式使修改文件的网络配置生效：

   1） 执行service network restart命令，重启网络服务（推荐）

   2） 重启计算机

**配置 动态 ip（自动分配）**

1. 使用chkconfig命令让网络服务在系统启动级别是2345时默认启动。
   `chkconfig –level 2345 network on`
   修改ifcfg-eth0文件，设置ONBOOT的值为yes，让网络服务启动时使用该网卡。设置BOOTPROTO的值为dhcp，让网卡从DHCP服务器自动获取IP地址。

2. 修改ifcfg-eth0文件，设置ONBOOT的值为yes，让网络服务启动时使用该网卡。设置BOOTPROTO的值为dhcp，让网卡从DHCP服务器自动获取IP地址。
   使用 命令 修改 vi /etc/sysconfig/network-scripts/ifcfg-eth0
   `ONBOOT=yes
   BOOTPROTO=dhcp`



# 第五天：Shell编程与bash、源文件编译

## 从第一行开始

我们可以使用任意一种文字编辑器，比如gedit、kedit、emacs、vi等来编写shell脚本，它必须以如下行开始（必须放在文件的第一行）：  

```
#!/bin/bash
```

此行称为 [shebang](https://en.wikipedia.org/wiki/shebang)（就是 sharp (#) + bang (!) 的意思），会指引操作系统使用接下来指定的程序运行此文件。此处 `/bin/bash` 执行我们的文件。 

一些人使用 `#!/bin/sh` 来让 `sh` 执行文件，按照习惯这表示任何支持 [POSIX shell 命令语言](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html)的 `sh`程序。为了用上我们所喜欢的 `bash` 拓展语法功能，我们就不这么用了。如果你使用别的脚本，例如 `/bin/tcsh`，照着样子加个 `#!` 就行。 

编辑结束并保存后，如果直接要执行该脚本，必须先使其具有可执行属性：  

```
chmod +x filename
```

此后在该脚本所在目录下，输入 `./filename<tt> 即可执行该脚本。  `

## 变量

Shell 变量默认全都是字符串。 

### 变量赋值和引用

`Shell 编程中，使用变量无需事先声明。变量名的命名遵守正则表达式 <tt>[a-zA-Z_][a-zA-Z0-9_]+`，也就是由大小写字母数字和下划线组成，且不能以数字开头。请注意 shell 环境中的确有以数字和特殊符号开头的变量名，但是那些东西不可以用接下来的方式赋值。 

需要给变量赋值时，可以这么写：  

```
varname=值 [var2=val2 ....]
```

请注意这边等号左右不能有空格。 要取用一个变量的值，只需在变量名前面加一个 `$`： 

```
# assign
a="hello world"  # 等号两边均不能有空格存在
# print
printf '%s\n' "A is: $a"
```

挑个自己喜欢的编辑器，输入上述内容，并保存为文件 first，然后执行 chmod +x first 使其可执行，最后输入 ./first 执行该脚本。其输出结果如下： 

```
A is: hello world
```

有时候变量名可能会和其它文字（匹配最长的符合变量名或特殊变量名要求的内容）混淆，比如：  

```
num=2
echo "this is the $numnd"   # 输出 this is the       — shell 尝试寻找 $numnd 的值
echo "this is the ${num}nd" # 输出 this is the 2nd   — 修好了！
# 花括号可以隔开变量名，但是放歪了的话…
echo "this is the {$num}nd" # 输出 this is the {2}nd — 切是切开了，但是…
```

### 变量算术

Shell 变量默认都是字符串。这也就是说，你尝试这么做，肯定没用： 

```
var=1
var=$var+1
echo $var # 输出 1+1
```

我们可以用很多方法达成我们的目标。首先是好孩子的方法——C 风格表达式。 

```
var=0
# bash 里面可以用 (( )) 执行 C 风格的算术表达式。
# 如果你接下来还会读 if 那一段的话，你还会知道这玩意的返回和 C 的非零真假判断一致。
(( var += 1 )) # 这是一种，现在 var 是 1
(( var++ ))    # 这也是一种自增，2
(( var = var * var )) # 怎么来乘法了！var 现在是 4。
let 'var = var / 3'   # 还是只有 bash 才能用的拓展。除法是整数除法，向 0 舍入，1。
# 来一点不一定要 bash 的方法吧，毕竟 sh 还有很多种，总不能全报错了吧。
# $(( )) 会展开成为这个 C 表达式求值的结果。以前 bash 有个 $[ ] 一样，但是别去用。
echo $((var += 2))    # echo 出 3，var 现在是 3。
var=$((var-1))        # 展开成 var=2，var 现在是……还用说吗，2。
```

以前还有人用 expr 之类的外部程序来，不过这属于杀鸡用牛刀。并且调用外部程序浪费时间性能差。 

```
var=1
var=$(expr "$var" + 1) # expr 收到三个参数 '1' '+' '1'，

                      # 按照 expr --help 里面写的方法运行
                      # 然后输出替换掉 $() 这里变成 var=2。

var=`expr "$var" + 1`  # 前面一行的老写法，千万千万不要学。
```

## Shell里的流程控制

### if 语句

if 表达式如果条件命令组为真，则执行 then 后的部分。标准形式： 

```
if 
  判断命令，可以有很多个，真假取最后的返回值
then
  如果前述为真做什么
[ # 方括号代表可选，别真打进去了！
elif
  可以再来个判断，如果签名为假继续尝试这里
then
  如果前述为真做什么 ]
else
  如果全都不行做什么
fi # 结束，就是倒写的 if 啦。
```

现实生活中一般判断只有一个命令，所以你看到的一般是： 

```
if ....; then # 你也可以写成 if 之后换行，这样就不用分号了。
  ....
fi
```

大多数情况下，可以使用测试命令来对条件进行测试，比如可以比较字符串、判断文件是否存在及是否可读等等……在 bash 中一般采用更好用的 ` ... ` 语法进行条件测试，而通用方法是 `[ ... ]<tt>（相当于 <tt>test ...`）。两者都接纳的常用测试语句有： 

- `-f "filename"`

  判断是否是一个文件

- `-x "/bin/ls"`

  判断/bin/ls是否存在并有可执行权限

- `-n "$var"`

  判断 $var 变量是否有值

- `"$a" == "$b"`

  判断$a和$b是否相等

前者可以使用 `help [[` 查询用法，后者使用 `help [` (bash) 或 `man test` 查询。下面的语句用到了这个内容： 

```
if [ "${SHELL}" == "/bin/bash" ]; then
  echo "your login shell is the bash (bourne again shell)"
else
  echo "your login shell is not bash but ${SHELL}"
fi
```

变量 `$SHELL` 包含有登录shell的名称，我们拿它和 `/bin/bash` 进行比较以判断当前使用的shell是否为bash。你可能会问了，要是 bash 路径不是这个呢？ 

### && 和 || 操作符

熟悉C语言的朋友可能会喜欢下面的表达式： 

```
[ -f "/etc/shadow" ] && echo "This computer uses shadow passwords"
```

这里的 && 就是一个快捷操作符，如果左边的表达式为真（返回  0——“成功”）则执行右边的语句，你也可以把它看作逻辑运算里的与操作。上述脚本表示如果/etc/shadow文件存在，则打印“This  computer uses shadow passwords”。 

同样shell编程中还可以用或操作 (||)，例如： 

```
#!/bin/bash

mailfolder=/var/spool/mail/james
[ -r "$mailfolder" ] || { echo "Can not read $mailfolder"; exit 1; }
echo "$mailfolder has mail from:"
grep "^From " $mailfolder
```

该脚本首先判断mailfolder是否可读，如果可读则打印该文件中以"From"开头的行。如果不可读则或操作生效，打印错误信息后脚本退出。需要注意的是，这里我们必须使用如下两个命令： 

```
{
  echo "Can not read $mailfolder"; # 打印错误信息
  exit 1; # 退出程序
}
```

我们使用花括号以组合命令的形式将两个命令放到一起作为一个命令使用。即使不用与和或操作符，我们也可以用if表达式完成任何事情，但是使用与或操作符会更便利很多。 

要注意 Shell 中的 && || 程序流操作符不表现任何优先级区别，完全是先看到谁就先处理谁的关系。 

### case 语句

case表达式可以用来匹配一个给定的字符串，而不是数字（可别和C语言里的switch...case混淆）。 

```
case ... in
   ...) do something here 
   ;;
esac
```

file命令可以辨别出一个给定文件的文件类型，如：file lf.gz，其输出结果为： 

```
lf.gz: gzip compressed data, deflated, original filename,
last modified: Mon Aug 27 23:09:18 2001, os: Unix
```

我们利用这点写了一个名为smartzip的脚本，该脚本可以自动解压bzip2, gzip和zip 类型的压缩文件： 

```
#!/bin/bash

ftype="$(file "$1")"
case "$ftype" in
"$1: Zip archive"*)
   unzip "$1" ;;
"$1: gzip compressed"*)
   gunzip "$1" ;;
"$1: bzip2 compressed"*)
   bunzip2 "$1" ;;
*)
   echo "File $1 can not be uncompressed with smartzip";;
esac
```

你可能注意到上面使用了一个特殊变量 `$1`，该变量包含有传递给该脚本的第一个参数值。也就是说，当我们运行： 

```
smartzip articles.zip
```

`$1` 就是字符串 articles.zip。 

### select 循环语句

select 循环语句是bash的一种扩展应用，擅长于交互式场合。 

用户可以从一组不同的值中进行选择：  

```
pocket=()
select var in 跳跳糖 糖 很多糖 企鹅糖; do
  echo "除了 $var 还要什么吗？"
  if ((RANDOM%4 == 0)); then
    echo "呀！时间不够了，快上车！"
    break # break 还是那个 break
  fi
  pocket+=("$var")
done
echo "你最后说的那个 $var 弄丢了……"
IFS='、'
echo "现在口袋里只有：${pocket[*]}。"
IFS=$' \t\n'
```

下面是一个简单的示例：  

```
#!/bin/bash

echo "What is your favourite OS?"
select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do
  break;
done
echo "You have selected $var"
```

该脚本的运行结果如下：  

```
What is your favourite OS?
1) Linux
2) Gnu Hurd
3) Free BSD
4) Other
#? 1
You have selected Linux
```

### while/for 循环

在shell中，可以使用如下循环： 

```
while ...; do
   ....
done
```

只要测试表达式条件为真，则while循环将一直运行。关键字"break"用来跳出循环，而关键字”continue”则可以跳过一个循环的余下部分，直接跳到下一次循环中。 

for循环会查看一个字符串列表（字符串用空格分隔），并将其赋给一个变量： 

```
for var in ....; do
   ....
done
```

下面的示例会把A B C分别打印到屏幕上： 

```
#!/bin/bash

for var in A B C ; do
   echo "var is $var"
done
```

下面是一个实用的脚本showrpm，其功能是打印一些RPM包的统计信息： 

```
#!/bin/bash

# list a content summary of a number of RPM packages
# USAGE: showrpm rpmfile1 rpmfile2 ...
# EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm
for rpmpackage in "$@"; do
   if [ -r "$rpmpackage" ];then
      echo "=============== $rpmpackage =============="
      rpm -qi -p $rpmpackage
   else
      echo "ERROR: cannot read file $rpmpackage"
   fi
done
```

这里出现了第二个特殊变量$@，该变量包含有输入的所有命令行参数值。如果你运行showrpm openssh.rpm w3m.rpm  webgrep.rpm，那么 "$@"(有引号) 就包含有 3 个字符串，即openssh.rpm, w3m.rpm和  webgrep.rpm。$*的意思是差不多的。但是只有一个字串。如果不加引号，带空格的参数会被截断。 

## Shell里的一些特殊符号

### 引号

在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓的扩展是指程序会把通配符（比如*）替换成适当的文件名，把变量替换成变量值。我们可以使用引号来防止这种扩展，先来看一个例子，假设在当前目录下有两个jpg文件：mail.jpg和tux.jpg。 

```
#!/bin/bash

echo *.jpg   # => mail.jpg tux.jpg
```

引号（单引号和双引号）可以防止通配符*的扩展： 

```
#!/bin/bash

echo "*.jpg"  # => *.jpg
echo '*.jpg'  # => *.jpg
```

其中单引号更严格一些，它可以防止任何变量扩展；而双引号可以防止通配符扩展但允许变量扩展： 

```
#!/bin/bash

echo $SHELL   # => /bin/bash
echo "$SHELL" # => /bin/bash
echo '$SHELL' # => $SHELL
```

此外还有一种防止这种扩展的方法，即使用转义字符——反斜杠`\`： 

```
echo \*.jpg   # => *.jpg
echo \$SHELL  # => $SHELL
```

## Here Document

当要将几行文字传递给一个命令时，用here document是一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果使用here  document就不必用echo函数一行行输出。Here document以 <<  开头，后面接上一个字符串，这个字符串还必须出现在here  document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here document打印帮助：  

```
#!/bin/bash

# we have less than 3 arguments. Print the help text:
if [ $# -lt 3 ] ;; then
cat << HELP

ren -- renames a number of files using sed regular expressions USAGE: ren 'regexp' 'replacement' files...

EXAMPLE: rename all *.HTM files in *.html:
   ren 'HTM$' 'html' *.HTM

HELP                #这里HELP要顶格写，前面不能有空格或者TAB制表符。如果cat一行写成cat &lt;&lt; -HELP，前边可以带TAB.
   exit 0
fi
OLD="$1"
NEW="$2"
# The shift command removes one argument from the list of
# command line arguments.
shift
shift
# $@ contains now all the files:
for file in "$@"; do
   if [ -f "$file" ]&nbsp;; then
      newfile=`echo "$file" | sed "s/${OLD}/${NEW}/g"`
      if [ -f "$newfile" ]; then
　　　　   echo "ERROR: $newfile exists already"
      else
         echo "renaming $file to $newfile ..."
         mv "$file" "$newfile"
      fi
   fi
done
```

示例有点复杂，我们需要多花点时间来说明一番。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量$# 表示包含参数的个数)  。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从参数列表中删除，这样原来的第三个参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。接着我们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了目的：得到了旧文件名和新文件名。然后使用  mv命令进行重命名 

## Shell里的函数

如果你写过比较复杂的脚本，就会发现可能在几个地方使用了相同的代码，这时如果用上函数，会方便很多。函数的大致样子如下：  

```
# 别笑，bash 里面函数名的确可以这样……
# (POSIX sh 函数名倒是和变量名要求差不多)
我是一个函数() {
  # 函数里面 $1 $2 对应函数所接受到的第一、第二……个参数。
  这里有很多命令
}
```

函数没有必要声明。只要在执行之前出现定义就行 

下面是一个名为xtitlebar的脚本，它可以改变终端窗口的名称。这里使用了一个名为help的函数，该函数在脚本中使用了两次：  

```
#!/bin/bash

help()
{
cat << HELP
xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole
USAGE: xtitlebar [-h] "string_for_titelbar"
OPTIONS: -h help text
EXAMPLE: xtitlebar "cvs"
HELP
exit 0
}
# in case of error or if -h is given we call the function help:
if [[ $1 == '' || $1 == '-h' ]]; then
  help
fi
# send the escape sequence to change the xterm titelbar:
echo -e "\033]0;$1\007"
#
```

在脚本中提供帮助是一种很好的编程习惯，可以方便其他用户（和自己）使用和理解脚本。 

## 命令行参数

我们已经见过 `$*` 和 `$1`,  $2 ... $9  等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-h选项）。但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值  (比如文件名)。  

有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无疑是一个不错的方法。  

```
#!/bin/bash
 
help()
{
   cat &lt;&lt; HELP
   This is a generic command line parser demo.
   USAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2
HELP
   exit 0
}
  
while [ -n "$1" ]; do
case "$1" in
   -h) help;shift 1;; # function help is called
   -f) opt_f=1;shift 1;; # variable opt_f is set
   -l) opt_l=$2;shift 2;; # -l takes an argument -&gt; shift by 2
   --) shift;break;; # end of options
   -*) echo "error: no such option $1. -h for help";exit 1;;
   *) break;;
esac
done
 
echo "opt_f is $opt_f"
echo "opt_l is $opt_l"
echo "first arg is $1"
echo "2nd arg is $2"
```

你可以这样运行该脚本：  

```
cmdparser -l hello -f -- -somefile1 somefile2
```

返回结果如下：  

```
opt_f is 1
opt_l is hello
first arg is -somefile1
2nd arg is somefile2
```

这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数。 

## Shell脚本示例

### 一般编程步骤

现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。写一个框架脚本（framework.sh），该脚本包含了大多数脚本需要的框架结构，是一个非常不错的主意。这样一来，当我们开始编写新脚本时，可以先执行如下命令： 

```
cp framework.sh myscript
```

然后再插入自己的函数。 

让我们来看看如下两个示例。 

### 二进制到十进制的转换

脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：  

```
#!/bin/bash
# vim: set sw=4 ts=4 et:
help()
{
   cat << HELP
   
b2d -- convert binary to decimal
 
USAGE: b2d [-h] binarynum
 
OPTIONS: -h help text
 
EXAMPLE: b2d 111010
will return 58
HELP
   exit 0
}
 
error()
{
   # print an error and exit
   echo "$1"
   exit 1
}
 
lastchar()
{
   # return the last character of a string in $rval
   if [ -z "$1" ]; then
      # empty string
      rval=""
      return
   fi
   # wc puts some space behind the output this is why we need sed:
   numofchar=`echo -n "$1" | sed 's/ //g' | wc -c ` 
   #sed 's/ //g'  所有空白去掉  sed 's/ /\t/g' 所有空白用t代替
   # now cut out the last char  抓取第numofchar个字节
   rval=`echo -n "$1" | cut -b $numofchar`
}
 
chop()
{
   # remove the last character in string and return it in $rval
   if [ -z "$1" ]; then
      # empty string
      rval=""
      return
   fi
   # wc puts some space behind the output this is why we need sed:
   numofchar=`echo -n "$1" | wc -c | sed 's/ //g' `
   if [ "$numofchar" = "1" ]; then
      # only one char in string
      rval=""
      return
   fi
   numofcharminus1=`expr $numofchar "-" 1`
   # now cut all but the last char:
   rval=`echo -n "$1" | cut -b -$numofcharminus1` 
   #原来的 rval=`echo -n "$1" | cut -b 0-${numofcharminus1}`运行时出错.
   #原因是cut从1开始计数，应该是cut -b 1-${numofcharminus1}
}
 
while [ -n "$1" ]; do
case $1 in
   -h) help;shift 1;; # function help is called
   --) shift;break;; # end of options
   -*) error "error: no such option $1. -h for help";;
   *) break;;
esac
done

# The main program
sum=0
weight=1
# one arg must be given:
[ -z "$1" ] &amp;&amp; help
binnum="$1"
binnumorig="$1"
 
while [ -n "$binnum" ]; do
   lastchar "$binnum"
   if [ "$rval" = "1" ]; then
      sum=`expr "$weight" "+" "$sum"` 
      # $expr 10 + 10    20 expr提示是计算操作
   fi
   # remove the last position in $binnum
   chop "$binnum"
   binnum="$rval"
   weight=`expr "$weight" "*" 2`
done
 
echo "binary $binnumorig is decimal $sum"
#
```

该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制"10"可以这样转换成十进制：  

```
0 * 1 + 1 * 2 = 2
```

为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。 

但是还记得前面怎么说的吗？进制转换哪需要这么麻烦： 

```
#!/bin/bash
while read -p 'input a binary...' num; do
  if [[ $num == *[!01]* ]]; then
    echo "含有 0 1 之外的字符"
  fi
  echo "$((0x$num))"      # 在 num 头上糊一个 0x 然后跑数学计算——就完事了！
  printf "%d\n" "0x$num"    # printf 也可以凑热闹啊
done
```

如果你喜欢自己算的话，其实也可以从左到右来（反正数学计算不要有事没事玩 expr 啦）： 

```
#!/bin/bash
# 人人皆知的 Horner 规则
value=0
echo "写一堆 1 0 完了回车"
while read -n 1 char; do
  case $char in
    (0|1) ;;      # 好
    ('')  break;; # 没了
    (*)   echo "你说啥？"; break;;
  esac
  ((value *= 2))
  ((value += char))
done
echo "$value"
```

### 文件循环移动

你可能有这样的需求并一直都这么做：将所有发出邮件保存到一个文件中。但是过了几个月之后，这个文件可能会变得很大以至于该文件的访问速度变慢；下面的脚本  rotatefile  可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，而原来的outmail.1就变成了  outmail.2 等等...  

```
#!/bin/bash
# vim: set sw=4 ts=4 et:
 
ver="0.1"
help()
{
   cat << HELP
   rotatefile -- rotate the file name
   USAGE: rotatefile [-h] filename
   OPTIONS: -h help text
   EXAMPLE: rotatefile out
 
   This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1
   and create an empty out-file
 

   version $ver

HELP

   exit 0
}

if [[ $1 == '-h' || $1 == '' ]]; then
  help
fi

filename=$1

# 我们先找到最大的数字再说。
max=0
while [ -f "$filename.$((++max))" ]; do
  : # 什么都不用做，我们已经顺手用 ++max 自增了 max 了。
done

# 然后从最大的一路重命名下来。
for ((i=max; i>0; i--)); do
  # 数字加个 1，好给前一个让位子。
  mv "$filename.$i" "$filename.$((i+1))"
done
 
# 最后我们点名要重命名的：
if [ -f "$filename" ]; then
   mv "$filename" "$filename.1"
fi

# 重新创建一下。
: > "$filename"
```

。 

## 脚本调试

最简单的调试方法当然是使用echo命令。你可以在任何怀疑出错的地方用echo打印变量值，这也是大部分shell程序员花费80%的时间用于调试的原因。Shell脚本的好处在于无需重新编译，而插入一个echo命令也不需要多少时间。 

shell也有一个真正的调试模式，如果脚本"strangescript"出错，可以使用如下命令进行调试： 

```
sh -x strangescript
```

上述命令会执行该脚本，同时显示所有变量的值。 

shell还有一个不执行脚本只检查语法的模式，命令如下： 

```
sh -n your_script
```

这个命令会返回所有语法错误。 

我们希望你现在已经可以开始编写自己的shell脚本了，尽情享受这份乐趣吧！ :) 

## 定时任务

linux通过atd和crond这两个系统服务实现一次性／周期性计划任务的功能．
/etc/init.d/atd  status（service  atd status） 可以查看atd服务进程是否启用 
用户的计划任务，只执行一次，例如今晚关机，一次性的计划任务，用at
计划任务后台需要有个进程等待执行任务，at任务会有个后台任务叫做atd进程，时刻内存中运行。
atd中的d标示daemon，daemon守护神和恶魔的意思，守护进程，后台进程。
命令格式：at \[参数\]
参考示例： at 5pm+3 days

参数：
>
>-m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出
>-I atq的别名
>-d atrm的别名
>-v 显示任务将被执行的时间
>-c 打印任务的内容到标准输出
>-V 显示版本信息
>-q<列队> 使用指定的列队
>-f<文件> 从指定文件读入任务而不是从标准输入读入
>-t<时间参数> 以时间参数的形式提交要运行的任务 
>

TIME：时间格式，这里可以定义出什么时候要进行 at 这项任务的时间，格式有：

>#在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此任务
>>HH:MM
>
>#强制规定在某年某月的某一天的特殊时刻进行该项任务
>>HH:MM YYYY-MM-DD
>
>#强制规定在某年某月的某一天的特殊时刻进行该项任务
>>HH:MM[am|pm] [Month] [Date]
>
>#在某个时间点再加几个时间后才进行该项任务
>>HH:MM[am|pm] + number [minutes|hours|days|weeks]
>

计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务
删除已经设置的任务： atrm 7（任务编号）
我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制。加上这两个文件后， at 的工作情况是这样的：

>先找寻 /etc/at.allow 这个文件，写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at (即使没有写在 at.deny 当中);
>如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件，若写在这个 at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用 at 命令了。
>如果两个文件都不存在，那么只有 root 可以使用 at 这个命令

crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。

Linux下的任务调度分为两类，系统任务调度和用户任务调度。

在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件

使用者权限文件：

>/etc/cron.deny  说明：该文件中所列用户不允许使用crontab命令
>/etc/cron.allow  说明：该文件中所列用户允许使用crontab命令
>/var/spool/cron/  说明：所有用户crontab文件存放的目录,以用户名命名

用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： 
minute   hour   day   month   week   command

>minute： 表示分钟，可以是从0到59之间的任何整数。
>hour：表示小时，可以是从0到23之间的任何整数。
>day：表示日期，可以是从1到31之间的任何整数。
>month：表示月份，可以是从1到12之间的任何整数。
>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

在以上各个字段中，还可以使用以下特殊字符：

>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜>线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。

/etc/crontab文件包括下面几行：
```
[root@localhost ~]# cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=""HOME=/
 
# run-parts
51 * * * * root run-parts /etc/cron.hourly
24 7 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
```
前 四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行 命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。
**crontab命令详解**
1．命令格式：
crontab [-u user] file
crontab \[-u user\][ -e | -l | -r ]
2．命令功能：
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。
3．命令参数：
-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。
file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
-i：在删除用户的crontab文件时给确认提示。
删除crontab文件
要删除crontab文件，可以用：
    $ crontab -r
恢复丢失的crontab文件
如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：
     $ crontab <filename>
    其中，<filename>是你在$ H O M E目录中副本的文件名。
**使用实例**

>
>实例1：每1分钟执行一次command
>
>command
>实例2：每小时的第3和第15分钟执行
>3,15 * * * * command
>实例3：在上午8点到11点的第3和第15分钟执行
>3,15 8-11 * * * command
>实例4：每隔两天的上午8点到11点的第3和第15分钟执行
>3,15 8-11 */2 * * command
>实例5：每个星期一的上午8点到11点的第3和第15分钟执行
>3,15 8-11 * * 1 command 
>实例6：每晚的21:30重启smb 
>30 21 * * * /etc/init.d/smb restart
>实例7：每月1、10、22日的4 : 45重启smb 
>45 4 1,10,22 * * /etc/init.d/smb restart

## 系统开关机操作

shutdown  安全关机

poweroff  立刻关机 

halt  立刻关机

reboot  重新启动

shutdown -h 10   `10  分钟后自动关机 `

**参考参数**

| 参数 | 长参数 | 描叙                                                         |
| ---- | ------ | ------------------------------------------------------------ |
| -a   |        | Use /etc/shutdown.allow.                                     |
| -c   |        | 中断关机：当执行"shutdown   -h 12:00"指令时，只要按+键就可以中断关机的指令 |
| -f   |        | 重新启动时不进行磁盘检测（fsck）                             |
| -F   |        | 重新启动时进行磁盘检测（fsck）                               |
| -h   |        | 关闭电源                                                     |
| -k   |        | 模拟关机（不是真的关机），只是向登录者发送警告信息出去！     |
| -n   |        | 不调用init进程进行关机，而是强行关机                         |
| -r   |        | 关闭系统然后重新启动，类似于Windows平台restart               |
| -t   |        | 延迟关机的时间                                               |
| -w   |        | 仅做测试，并不真的将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件 |
|      | --help | 显示命令在线帮助                                             |

# 附录：

## find命令参数参考：

find 查找文件 -name 指定查找文件名， 可以使用 pattern匹配的字符, 默认从当前目录中查找  -exec \<Command\> 

```shell
find -name '*.py'  #查找当前目录下所有的.py文件
find -name '*.py' | xargs  -E './3.py'  #查找所有 在./3.py文件之前的所有py文件
find -name '*.py' -exec python3 {} \;   #  {} 查找出来的.py文件
find -name '3.py' -exec cat {} \;   #  如果查找到3.py文件时，则会显示这个文件的内容,   如果查找的结果只有一个文件时，可以试着 去掉 { } \;

```

find pathname -options [-print -exec -ok ...]

### 命令参数：

|参数|说明|
|--|------|
|pathname|find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。|
|-print|find命令将匹配的文件输出到标准输出。u-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。 |
|-ok| 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行.|
### option选项：

|参数|说明|
|--|------|
|-name |按照文件名查找文件|
|-perm |按照文件权限来查找文件|
|-prune  |使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略|
|-user  | 按照文件属主来查找文件|
|-group  |按照文件所属的组来查找文件|
|-mtime -n +n  |按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项|
|-nogroup | 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在|
|-nouser   |查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在|
|-newer file1 ! file2  |查找更改时间比文件file1新但比文件file2旧的文件。|
|-type  |查找某一类型的文件，诸如：b - 块设备文件、d - 目录、c - 字符设备文件、p - 管道文件、l - 符号链接文件、f - 普通文件|
|-size n：[c]| 查找文件长度为n块的文件，带有c时表示文件长度以字节计|
|-depth|在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找|
|-fstype|查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息|
|-mount|在查找文件时不跨越文件系统mount点|
|-follow|如果find命令遇到符号链接文件，就跟踪至链接所指向的文件|
|-cpio|对匹配的文件使用cpio命令，将这些文件备份到磁带设备中|
|-amin n  | 查找系统中最后N分钟访问的文件|
|-atime n | 查找系统中最后n*24小时访问的文件|
|-cmin n   |查找系统中最后N分钟被改变文件状态的文件|
|-ctime n  |查找系统中最后n*24小时被改变文件状态的文件|
|-mmin n   |查找系统中最后N分钟被改变文件数据的文件|
|-mtime n  |查找系统中最后n*24小时被改变文件数据的文件|


