# 第一天：面向对象编程

## 什么是面向对象

面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。和其并列的另外一种编程思想《面向过程编程》为我们设计程序的两大主要编程思想。

面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。



## 面向对象编程的实现

### 相关概念

1. 类：类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类是一种用户定义类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。
2. 实例：实例指类实例化的结果，也称为对象。是我们在程序中所要使用的一个个具体的操作实体。
3. 实例化：实例化是指在面向对象的编程中，用类创建对象的过程。
4. 私有属性：一般定义为仅能在内部使用的属性，在python中指以\_\_开头命名的方法及属性。注意：python中的私有属性事实上可以在外部使用。
5. 类属性：我们定义出来的属于类的属性。该属性影响该类的所有实例。
6. 实例属性：实例属性属于实例，仅影响当前实例。需要注意的是在访问的时候遵循向下开放原则，修改遵循向上闭合原则即著名的开闭原则。
7. 继承：类（class）可以通过继承获得父类的所有属性及方法。类的默认继承类为object，因此object是所有类的祖类。
8. 重写：在子类中可以声明父类中的同名类实现自己的业务逻辑，这种方法叫做类的重写。

### 类的定义语法格式

```python
class 类名([父类1，......]):
    '''
    类说明文档
    '''
    [类属性1名 = 值]
    [类属性2名 = 值
    
    [def 方法1名(参数1[，......]):
        方法代码段
    [@装饰器] 
    def 方法2名(参数1[，......]):
        方法代码段]
```

#### 命名规则：

1. 类名: 遵循标识符命名规则; 见名知意;首字母大写.
2. 属性名: 遵循标识符命名规则; 见名知意.如果属性作为常量，一般全字母大写。
3. 方法名: 遵循标识符命名规则; 见名知意.
4. 按照PE8规范建议使用空行来间隔函数与类，函数与函数之间空一行  类之间空两行。

### 定义规则：

1. 对于方法有且必须有一个参数代表自身，一般写为self（在实例方法中使用，代表当前实例）、cls(在类方法中使用，代表类)。
2. 使用\_\_slots\_\_属性限制该类的实例所能拥有的属性。
3. 可以使用super()函数获取父类的实例，需要注意的是在多继承模式下super方式要获取父类的方法将会按照自左至右的顺序进行优先匹配。顺序可以使用当前类的mro方法获取，该方法获取的是当前类的\_\_mro\_\_属性，在早期版本中的顺序遵循为深度优先。不过我们不用关注了，3.x之后均为广度优先方式。
4. 我们亦可以使用：类名.实例方法名(self,参数1[,......])的方式调用父类的方法。
5. 通常我们使用：\_\_init\_\_方法进行初始化类属性。

#### self的理解

和普通数相比，在类中定义的方法函数有一点不同，就是**第一参数**永远是**类的本身实例变量**`self`，并且调用时，不用传递该参数。这个参数指向的是我们将来的实例自己，因为我们在定义的时候这个实例还是不存在的，所以使用self进行代替。因此这个self其实可以是一个其他符号，不过我们不建议这样做。在python中大家已经约定成俗的固定了这种写法。

### 实例对象的创建（实例化）

实例化类的结果就是实例对象，这个过程叫做实例化。实现的代码方式是：

flag = classname([arg,... ...])

代表我们创建一个实例对象并赋值给flag变量，调用类的参数将有\_\_init\_\_方法定义确定。

## 类属性与类方法的实现

类属性我们一般我们直接在方法之外定义即可，类方法定义需要用到内置的装饰器@classmethod,该方法的第一个参数一般写为cls代表的时当前类自身。如下示例：

```python
class ClassA(object):

    @classmethod
    def func_a(cls):#参数cls有且必须有，代表类对象自身
        print(type(cls), cls)


if __name__ == '__main__':

    ClassA.func_a()

    ca = ClassA()
    ca.func_a()
```

## 类与实例的区别与联系

类是对全体对象高度抽象之后的一个抽象的概念，用来确定示例应该拥有的属性以及方法等信息。而实例则是类的一个具象化的结果，是我们在程序的运行过程中真正使用的对象。我们所说的面向对象其实说的就是面向实例对象编程的方式（当然前提是我们应该预先定义好对象的模板样子即类：可以是我们自己定义的也可以时其他人定义的可以被我们所使用的类）。

需要注意的是类的方法及属性是属于所有该类型的实例所拥有，因此其改变会影响到该类的所有实例，而实例的仅属于实例自身所拥有仅影响其自身。因此按照开闭原则则当前实例不具备某个属性时将会去勒种查找并使用。

## 对象的起与终：构造[起] 与 析构[终]

Python涉及类的构造与初始化，有两个重要的方法：`__new__( )`和`__init__( )`和方法。前者完成实例对象的创建，后者完成对创建的实例对象的初始化工作。为更好的理解相关概念，我们先来看一个具体的例子：
```python
class MyClass(object):
    def __new__(cls, *args, **kwargs):
        print('__new__ called')
        return object.__new__(cls) #默认的工厂方法
    
    def __init__(self, name):
        print('__init__ called')
        self.name = name

if __name__ == '__main__':
    instance = MyClass("Learning Python")
```
MyClass类继承了object基类，实现了__new__()和__init__()方法，程序运行结果如下：
```python
__new__ called
__init__ called
```
通过上面的例子，对于__new__和__init__方法有个大致的印象。接下来，我们具体讲解相关的构造与初始化方法。
__new__()元构造方法
特殊方法__new__()是一个元构造程序，每当一个对象必须被factory类实例化时都会调用它，且__new__方法的调用在__init__之前。
与__init__()相比，__new__()方法更像一个真正的构造器，__new__方法的调用需要将类cls作为它的第一个调用参数，它的责任是返回一个类的新的实例，因此，它可以在对象创建之前或之后修改类的实例，从而确保实例被设置为一个希望的状态。
这里我们可以将此与__init__方法做个比较：__init__调用时需要要将类的实例作为第一个参数，并且它并不返回任何东西，它的职责就是初始化这个实例。有些情况下，创建一个实例并不需要调用__init__，但没有办法在不调用__new__时创建一个实例。
__init__在子类中不会被隐式调用（子类初始化时，必须显式的调用父类的__init__方法），所以__new__可以用来确定在整个类层次中完成初始化工作。它使得可以在比__init__更低层次上定义一个初始化，这个初始化总是被调用。__new__()和__init__()在类创建时，都传入了（相同）参数。
我们在这里总结了一下__new__()方法的一些规则：

1. __new__是一个静态方法

2. __new__第一个参数必须是类，其它参数可以被构造器调用引用

3. 子类__new__方法覆盖了基类的__new__方法，可以在子类的__new__方法中调用基类的__new__方法。基类的__new__方法的第一个参数必须是传递给子类__new__方法的类参数，而不是基类参数。如果传递的是基类，你将得到一个基类的实例。

4. 子类__new__方法必须调用基类的__new__方法，这是创建对象实例的唯一方法。子类__new__方法通过做两件事情影响对象实例：给基类的__new__方法传递不同的参数；在实例创建之后修改实例对象（例如修改必要的实例参数）。

5. __new__方法必须返回一个实例对象。尽管通常要求该方法返回的新对象是它传入类参数的一个实例，但并没有要求必须这么做。如果你返回一个已存在的对象，构造器仍会调用它的__init__方法。如果你返回了不同类的一个实例，它会调用自己的__init__方法。如果你忘记返回，Python回返回None。

6. 对于不可变类，如int, str，tuple等，子类的__new__方法可返回已存在对象的引用，这是为什么__init__方法不需要做任何事情的原因：缓存的对象会被一边又一边的初始化（另外一个原因是__new__返回了一个被完全初始化的对象实例，__init__方法不需要做任何初始化了）。

7. 当你子类化一个内置不可变类型并且希望加入一些可变状态，最好是在__init__方法中初始化这些可变状态，而非在__new__方法中。

8. 如果你想变更构造器的参数，你通常不得不同时复写__new__和__init__方法来接受新的参数。然而，大部分内置类型会忽略方法不使用的参数，特别是不可变类(int, long, float, complex, str, unicode,tuple)有一个哑的__init__方法，而可变类(dict, list, file, super, classmethod, staticmethod, property)有一个哑的__new__方法。内置类型object类(所有其它类的基类)的__new__和__init__方法都是哑的。
     __init__()实例初始化方法
       当类被调用时，实例化的第一步是创建实例对象。一旦实例对象创建了，Python检查是否实现了__init__()方法。默认情况下，如果没有定义__init__()，对实例不会施加任何特殊操作，任何所需的特定操作，都需要程序实现__init__()，覆盖其默认行为。如果__init__()没有实现，则返回它的对象，实例化过程完毕。
       然而，如果__init__()已经被实现，那么它将被调用，实例对象作为第一个参数(self)被传递进去，像标准方法调用一样。调用类时，传进的任何参数都交给了__init__()。实际中，你可以想像成这样：把创建实例的调用当成是对构造器的调用。
       总之，(a)你没有通过调用new 来创建实例，你也没有定义一个构造器。则Python 为你创建了对象; (b) __init__()，是在解释器为你创建一个实例后调用的第一个方法，在你开始使用它之前，这一步可以让你做些准备工作。
     析构器方法
     与构造器对应的，有一个特殊的析构器（destructor）方法名为__del__()。然而，由于Python 具有垃圾对象回收机制（靠引用计数)，这个函数要直到该实例对象所有的引用都被清除掉后才会执行。Python 中的析构器是在实例释放前提供特殊处理功能的方法，它们通常没有被实现，因为实例很少被显式释放。

     **扩展：**下面使用了sys模块下的getrefcount方法查看的是对象的引用计数，gc模块下的get_referrers方法返回指定对象的引用列表

```python
from sys import getrefcount
from gc import get_referrers
       
class MyClass(object):
    def __init__(self):
        print("MyClass init")
    
    def __del__(self):
        print("MyClass del")

if __name__ == '__main__':
    obj1 = MyClass()
    print("only one instance, refcount=%d" % getrefcount(obj1))
    obj3 = obj2 = obj1
    
    print("print the reference to obj1")
    print(get_referrers(obj1))
    print("now we have three instances now, refcount=%d" %getrefcount(obj1))
    del(obj2)
    print("After deleting the obj2, refcount=%d" % 	getrefcount(obj1))
    del(obj3)
    print("After deleting the obj3, refcount=%d" % getrefcount(obj1)) 
    del(obj1) 
    print("delete all instances")
```

运行结果

```python
MyClass init
only one instance, refcount=2
print the reference to obj1
[{'__doc__': '\nCreated on 2018年11月12日\n\n@author: xxg\n', '__loader__': <_frozen_importlib.SourceFileLoader object at 0x0000000000461710>, '__file__': 'E:\\workspace\\pythonstudy\\classtest\\testdel.py', '__package__': None, '__spec__': None, 'MyClass': <class '__main__.MyClass'>, '__cached__': None, 'get_referrers': <built-in function get_referrers>, 'obj3': <__main__.MyClass object at 0x0000000000461748>, '__builtins__': <module 'builtins' (built-in)>, 'obj2': <__main__.MyClass object at 0x0000000000461748>, '__name__': '__main__', 'getrefcount': <built-in function getrefcount>, 'obj1': <__main__.MyClass object at 0x0000000000461748>}]
now we have three instances now, refcount=4
After deleting the obj2, refcount=3
After deleting the obj3, refcount=2
MyClass del
delete all instances
```

总结以下__del__的使用：
1. 调用 del x 不表示调用了x.__del__() -----前面也看到，它仅仅是减少x 的引用计数。
2. 如果你有一个循环引用或其它的原因，让一个实例的引用逗留不去，该对象的__del__()可能永远不会被执行。
3. __del__()未捕获的异常会被忽略掉（因为一些在__del__()用到的变量或许已经被删除了）。不要在__del__()中干与实例没任何关系的事情。
4. 除非你知道你正在干什么，否则不要去实现__del__()。
5. 如果你定义了__del__，并且实例是某个循环的一部分，垃圾回收器将不会终止这个循环——你需要自已显式调用del。
6. 不要忘记首先调用父类的__del__()。
## 类的定制（重写\_\_reper\_\_,\_\_str\_\_）

python中包含很多内置的(Built-in)函数，异常，对象。分别有不同的作用，我们可以重写这些功能。这种形式就叫做类的定制，一般我们是通过对类的专有方法进行定制来使得我们的类型的对象获取到我们想要的一些类似标准类型的使用方式或者我们自己更独特的运行结果。下面我们通过一个简单的例子演示一下：__

```python
class Student(object):

    def __init__(self, name):
        self._name = name

m = Student("michael")
print(m)
```
运行结果
```
<__main__.Student object at 0x0000000003280EF0>
```

为了使print类的结果格式更加方便阅读我们重写__str__(self)方法

```python
class Student(object):

    def __init__(self, name):
        self._name = name
        
    def __str__(self):
        return "Student Name is %s !"% self._name


m = Student("michael")
print m
```
运行结果
```
Student Name is michael !
```

__repr__类似于__str__，不同的__repr__主要运用与开发者交互方面。

更多的专有方法介绍请参照附录部分的《类专有方法一览表》

## 访问限制

我看如下示例：
```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
 
    def print_score(self):
        print('%s--%s' % (self.name, self.score))
 
    def get_grade(self):
        if self.score >= 90:
            return 'A'
        elif self.score >= 70:
            return 'B'
        else:
            return 'C'
 
student2 = Student('Jack', 70)
print(student2.name, student2.score )
 
student2.print_score()
print(student2.get_grade())
----------------------------------
Jack 70
Jack--70
B
```
在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的`name`、`score`属性：

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：

```python
class Student(object):
 
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
 
    def print_score(self):
        print('%s--%s' % (self.__name, self.__score))
```

改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问`实例变量.__name`和`实例变量.__score`了 。
```python
std1 = Student('Mink', 80)
std1.__name
---------------------------------
Traceback (most recent call last):
     line 320, in <module>
    std1.name
AttributeError: 'Student' object has no attribute 'name'
```
如果又要允许外部代码修改score怎么办？可以给Student类增加set_score方法：
```python
class Student(object):
    ...
 
    def set_score(self, score):
        self.__score = score
```
原先那种直接通过student2.score = 70也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：
```python
class Student(object):
    ...
 
    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
```
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量：但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把`__name`改成不同的变量名。

## 扩展：关于`__slots__`属性限制

字典位于实例的“心脏”。`__dict__`属性跟踪所有实例属性。举例来说，你有一个实例 inst.它 有一个属性 foo，那使用 inst.foo 来访问它与使用 inst.\_\_dict\_\_['foo']来访问是一致的。 

字典会占据大量内存，如果你有一个属性数量很少的类，但有很多实例，那么正好是这种情况。 为内存上的考虑，用户现在可以使用`__slots__`属性来替代`__dict__`。 

`__slots__`本质上是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集 合来表示。它可以是一个列表，元组或可迭代对象。也可以是标识实例能拥有的唯一的属性的简单字符串。任何试图创建一个其名不在`__slots__`中的名字的实例属性都将导致 AttributeError 异常。我们可以运行以下两段代码看下效果。

```python
class Test():
    pass

test = Test()
test.name = '西红柿大人'
test.age = 108
test.sex = False

class SlottedClass(object):
    __slots__ = ('name','age')
    
slots_test = SlottedClass()
slots_test.name = '西红柿大人'
slots_test.age = 108
slots_test.sex = False
```

这种特性的主要目的是节约内存。其副作用是某种类型的"安全",它能防止用户随心所欲的动态 增加实例属性。带`__slots__`属性的类定义不会存在`__dict__`了（除非你在`__slots__`中增加 `__dict__`元素）。

需要注意的是当存在于继承关系时，`__slots__`属性的限制规则将为当前类与符及类的规则叠加的效果。而在任何类型中如果没有声明`__slots__`时其表现为没有限制。

## 练一练

# 第二天：继承、封装、多态

```python
继承性的好处：
①减少了代码的冗余，提供了代码的复用性
②提高了程序的扩展性 
③（类与类之间产生了联系）为多态的使用提供了前提

pytho中类继承的形式：单继承和多继承
```

## 继承

继承描述了基类的属性如何“遗传”给派生类。在继承关系中的的被继承类被称之为父类、基类或者超类。而继承类被称之为子类。一个子类可以继承它的基类的任何属性，不管 是数据属性还是方法。 子类需要继承时需要在定义时的类名之后的括号中列举出需要继承的类型对象。举个例子如下。P 是一个有一些属性和方法的简单类。C 从 P 继承而来（因此是它的子类），那么C也就具有了和P一样的属性及方法：

```python
class P(object): #parent class 父类  
    name = '张三丰'
    age = 180
    
    def speak(self):
        print('我是',self.name)
        
        
class C(P): #child class 子 类
    pass

c = C()
print(c.name,c.age)
c.speak()
```
我们在运行上面的代码的时候会发现类型C虽然没有定义name以及age属性但是其实例依然何以获取该属性，其结果表明了继承时子类是可以继承到父类的所有属性以及方法的。

当我们指定的基类有多个时（这种行为在python中是被允许的——被称之为多继承），那么子类就可以获取到所有父类的所有方法和属性。不过麻烦的是如果某几个基类中的有可能具有相同名称的属性或者方法。那么字类在使用的时候到底该用哪个呢？？？答案是默认情况下自左而右，谁先用谁。如下示例：

```python
class P1(object): #parent class 父类  
    name = '张三丰'
    age = 180
    
    def speak(self):
        print('我是',self.name)
        
class P2(object): #parent class 父类  
    name = '王二狗'
    age = 38
    
    def speak(self):
        print('我是',self.name)
        
class C(P1,P2): #child class 子 类
    pass
c = C()
print(c.name,c.age)
```

在继承时我们可以使用super函数获取父类的实例：

```python
class Animal():
    def __init__(self, name):
        self.name = name
 
    def saySomething(self):
        print("I am " + self.name)
 
class Dog(Animal):
    def __init__(self, name):
        super().__init__(name)
 
    def saySomething(self):
        print ("I am "+ self.name + ", and I can bark")
 
    def animal_say_1(self):
        # 子类调用父类的方法
        #  方式1
        super(Dog, self).saySomething()
 
    def animal_say_2(self):
        #  方式2 
        super().saySomething()
     
    def animal_say_3(self):
        # 方式3
        Animal.saySomething(self)
 
 
if __name__ == "__main__":
    dog = Dog("Blake")
    dog.saySomething()
    dog.animal_say_1()
    dog.animal_say_2()
    dog.animal_say_3()
    # 子类对象调用被覆盖的父类方法
    super(Dog, dog).saySomething()
```

需要注意的是文档字符串对类，函数/方法， 还有模块来说都是唯一的，所以特殊属性`__doc__`不会从基类中继承过来。 

## 方法重写

在前面我们对类的`__str__`和`__repe__`的实现实现了对类的定制，其实就是一种方法重写（覆盖、重载）。这个再次体现了我们在第二周时的关于开闭原则的说明。其本质就是对于父类的原有的方法进行了重写。按照我们对于标记符号的查找方式，我们只有在当前环境下找不到时才去上一级寻找。那么我们就可以在当前直接实现一个同名的对象属性不就相当于我们对于父级的同名属性对象实现了重新书写吗？请看下面的例子代码：

```python
class Animal():
    def __init__(self, name):
        self.name = name
 
    def saySomething(self):
        print("I am " + self.name)
 
class Dog(Animal):
    def __init__(self, name):
        super().__init__(name)
 
    def saySomething(self):
        print ("I am "+ self.name + ", and I can bark")
        
if __name__ == "__main__":
    animal = Animal("marker")
    animal.saySomething()
    dog = Dog("Blake")
    dog.saySomething()
```

因此：方法重写其本质就是子类对父类的同名方法进行覆盖实现。

## 关于多态

通过前面的继承以及方法重写其实我们发现当子类和父类都存在相同的方法时，我们说，子类的方法覆盖了父类的，在代码运行的时候，总是会调用子类的方法。这样，我们就获得了继承的另一个好处：多态。

要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：

```python
a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
```

判断一个变量是否是某个类型可以用`isinstance()`判断：

```python
>>> isinstance(a, list)
True
>>> isinstance(b, Animal)
True
>>> isinstance(c, Dog)
True
```

看来a、b、c确实对应着list、Animal、Dog这3种类型。

但是等等，试试：

```python
>>> isinstance(c, Animal)
True
```

看来c不仅仅是Dog，c还是Animal！

让我们仔细考虑下，这个情况是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例`c`时，我们认为`c`的数据类型是Dog没错，但`c`同时也是Animal也没错，Dog本来就是Animal的一种！所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行： 

```python
>>> b = Animal()
>>> isinstance(b, Dog)
False
```

Dog可以看成Animal，但Animal不可以看成Dog。

要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：

```python
def run_twice(animal):
    animal.run()
    animal.run()
```

当我们传入Animal的实例时，`run_twice()`就打印出：

```python
>>> run_twice(Animal())
Animal is running...
Animal is running...
```

当我们传入Dog的实例时，`run_twice()`就打印出：

```python
>>> run_twice(Dog())
Dog is running...
Dog is running...
```

当我们传入Cat的实例时，`run_twice()`就打印出：

```python
>>> run_twice(Cat())
Cat is running...
Cat is running...
```

看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：

```python
class Tortoise(Animal):
    def run(self):
        print 'Tortoise is running slowly...'
```

当我们调用run_twice()时，传入Tortoise的实例：

```python
>>> run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...
```

你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。

多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有`run()`方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的`run()`方法，这就是多态的意思：

对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用`run()`方法，而具体调用的`run()`方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保`run()`方法编写正确，不用管原来的代码是如何调用的。

**总结:**多态是在面向对象编程中由于类的继承实现从而使得一个类具有多种类型的形态的一种表现。

## 对象属性与类属性

由于Python是动态语言，根据类创建的实例可以任意绑定属性。

 

给实例绑定属性的方法是通过实例变量，或者通过`self`变量：

 

```python
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
```

但是，如果`Student`类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归`Student`类所有：

 

```python
class Student(object):
    name = 'Student'
```

当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：

 

```python
>>> class Student(object):
...     name = 'Student'
...
>>> s = Student() # 创建实例s
>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
>>> print(Student.name) # 打印类的name属性
Student
>>> s.name = 'Michael' # 给实例绑定name属性
>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
>>> del s.name # 如果删除实例的name属性
>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
```

从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。

## 类方法与静态方法

**一、实例方法**

实例方法就是类的实例能够使用的方法。如下： 

```python
class Foo:
    def __init__(self, name):
        self.name = name
    
    def hi(self):
        print(self.name) 


if __name__ == ‘__main__’:
    foo01 = Foo(‘letian’)
    foo01.hi()
    print(type(Foo))
    print(type(foo01))
    print(id(foo01))
    print(id(Foo))
```

**二、类方法**

类方法是将类本身作为对象进行操作的方法。类方法使用@classmethod装饰器定义，其第一个参数是类，约定写为cls。类对象和实例都可以调用类方法：

```python
class Foo:
    name = 'letian'
    @classmethod
    def hi(cls, x):
        print(cls.name * x )

 

if __name__ == '__main__':
    foo01 = Foo()
    foo01.hi(2)
    Foo.hi(3)
```

**三、静态方法**

静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，**但是和类本身没有交互**，即在静态方法中，不会涉及到类中的方法和属性的操作。可以理解为将静态方法存在此类的名称空间中。事实上，在python引入静态方法之前，通常是在全局名称空间中创建函数。

示例：定义一个关于时间操作的类，其中有一个获得当前时间的函数。

```python
import time
class TimeTest(object):
    def __init__(self,hour,minute,second):
        self.hour = hour
        self.minute = minute
        self.second = second
    @staticmethod   
    def showTime():       
        return time.strftime("%H:%M:%S", time.localtime())
 
     
print(TimeTest.showTime())    
t = TimeTest(2,10,10)
nowTime = t.showTime()
print(nowTime)
```

**静态函数可以通过类名以及实例两种方法调用！**

## 人开枪射击小案例

**第一步：分析题目。**

人开枪射击子弹。题目中有三个名词，分别是：人、枪、子弹。也就是说，至少要有三个类，分别是：人类、枪类、弹夹类（装子弹）。那么，我们再深入分析，三个类，每个类都有什么。

第一个是人类。
类名：Person（人）
属性：gun(枪)
行为：fire（开火）、fillBullet（装弹）

第二个是枪类。
类名：Gun（枪）
属性：bulletBox（弹夹）
行为：shoot（射击）

第三个是弹夹类
类名：BulletBox（弹夹）
属性：bulletCount（子弹）
行为：（这里没有，因为弹夹确实没什么行为。） 

**第二步，编写三个类的代码。**

Person类：

```python
class Person(object):
    def __init__(self, gun):
        self.gun = gun         #人首先要拥有一把枪    
    def fire(self):
        self.gun.shoot()       #人开火的时候调用枪射击。
    def fillBullet(self, count):
        self.gun.bulletBox.bulletCount = count      #在没子弹的时候，要能购买子弹。        
        print("购买子弹数：%d" %(count))
```

Gun类：

```python
class Gun(object):
    def __init__(self, bulletBox):
        self.bulletBox =bulletBox       #枪首先得有个弹夹    
    def shoot(self):
        if self.bulletBox.bulletCount == 0:    #判断子弹数，并输出信息。            
            print("没有子弹了，请购买子弹。") 
        else: 
            self.bulletBox.bulletCount -= 1      #每次开火，减少一颗子弹。                
            print("剩余子弹：%d发" % (self.bulletBox.bulletCount))
```

 BulletBox类：

```python
class BulletBox(object):
    def __init__(self, count):
        self.bulletCount = count   #弹夹用来装子弹就可以。
```

三个类的调用关系是人-》枪-》子弹。

简单逻辑：你人开枪射击子弹，首先得有一把枪，这把枪里得有弹夹，这个弹夹里得装有子弹。

**第三步，实现人开枪发射子弹的功能。**

```python
#定义三个对象

bulletBox = BulletBox(2)#弹夹  初始给上2发子弹。

gun = Gun(bulletBox)#枪

per = Person(gun)#人

#开始发射子弹
per.fire()
per.fire()
per.fire()
#发射三颗后，没有子弹，并提醒用户购买子弹。

#买上10颗子弹，并打印购买个数。
per.fillBullet(10)

#继续设计
per.fire()
```

# 第三天：面向对象高阶

## 动态添加属性方法

### 动态添加属性

####  添加对象属性

```python
class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

zhangsan = Person("张三", 18)
zhangsan.addr = "北京"    # 类对象zhangsan动态添加对象属性addr
print(zhangsan.name)    # 张三
print(zhangsan.age)     # 18
print(zhangsan.addr)    # 北京

lisi = Person("李四", 28)
print(lisi.name)        # 李四
print(lisi.age)         # 28
print(lisi.addr)        # ‘Person’ object has no attribute ‘addr’
```

由以上代码可知，Person类有两个属性：name和age。通过[对象名.属性名]给类对象zhangsan动态添加了对象属性addr，而Person的另一个类对象lisi却不能调用这个属性。
**注：通过对象名添加的对象属性，只有这个对象能使用。这个也是面向对象的特征之一封装特征的直接体现。**

#### 添加类属性

```python
class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

Person.addr = "北京"  # 类Person动态添加类属性addr

zhangsan = Person("张三", 18)
print(zhangsan.name)    # 张三
print(zhangsan.age)     # 18
print(zhangsan.addr)    # 北京

lisi = Person("李四", 28)
print(lisi.name)    # 李四
print(lisi.age)     # 28
print(lisi.addr)    # 北京
```

由以上代码可知，通过[类名.属性名]给类Person动态添加了类属性addr，Person的类对象zhangsan和lisi都能调用这个属性
**注：通过类名添加的类属性，这个类的所有对象都能使用**

### 动态添加方法

类中有三种方法，实例方法，静态方法和类方法，三种方法的区别如下：

- 实例方法：需要绑定到一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来
- 静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数
- 类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来

####  添加实例方法

```python
import types

class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

    def eat(self):
        print("---正在吃---")

    def run(self):
        print("---正在跑---")

zhangsan = Person("张三", 18)
zhangsan.eat()  # ---正在吃---
zhangsan.run = types.MethodType(run, zhangsan)  # 类对象zhangsan动态添加对象方法run()
zhangsan.run()  # ---正在跑---

lisi = Person("李四", 28)
lisi.eat()  # ---正在吃---
lisi.run()  # 'Person' object has no attribute 'run'
```

由以上代码可知，Person类有一个方法：eat()方法。通过[**types.MethodType(方法名, 对象名)**]给类对象zhangsan动态添加了对象方法run()，同理，Person的另一个类对象lisi不能调用这个方法

**注：通过对象名添加的对象方法，只有这个对象能使用**

添加静态方法

```python
class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

    def eat(self):
        print("---正在吃---")

@staticmethod
def staticRun():
    print("---正在跑---")

Person.staticRun = staticRun    # 类Person动态添加静态方法staticRun()

Person.staticRun()  # ---正在跑---

zhangsan = Person("张三", 18)
zhangsan.eat()        # ---正在吃---
zhangsan.staticRun()  # ---正在跑---

lisi = Person("李四", 28)
lisi.eat()        # ---正在吃---
lisi.staticRun()  # ---正在跑---
```

由以上代码可知，通过[**类名.静态方法名**]给类Person动态添加了静态方法staticRun()，Person类的Person的类对象zhangsan和lisi都能调用这个方法

**注：通过类名添加的静态方法，这个类及这个类的所有对象都能使用**

#### 添加类方法

```python
class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

    def eat(self):
        print("---正在吃---")

@classmethod
def classRun(cls):
    print("---正在跑---")

Person.classRun = classRun    # 类Person动态添加类方法classRun()

Person.classRun()  # ---正在跑---

zhangsan = Person("张三", 18)
zhangsan.eat()        # ---正在吃---
zhangsan.classRun()  # ---正在跑---

lisi = Person("李四", 28)
lisi.eat()        # ---正在吃---
lisi.classRun()  # ---正在跑---
```

由以上代码可知，通过[**类名.类方法名**]给类Person动态添加了类方法classRun()，Person类的Person的类对象zhangsan和lisi都能调用这个方法。

 **注：通过类名添加的类方法，这个类及这个类的所有对象都能使用**

####  添加静态方法

```python
class Person(object):
    def __init__(self, newName, newAge):
        self.name = newName
        self.age = newAge

    def eat(self):
        print("---正在吃---")

@staticmethod
def staticRun():
    print("---正在跑---")

Person.staticRun = staticRun    # 类Person动态添加静态方法staticRun()

Person.staticRun()  # ---正在跑---

zhangsan = Person("张三", 18)
zhangsan.eat()        # ---正在吃---
zhangsan.staticRun()  # ---正在跑---

lisi = Person("李四", 28)
lisi.eat()        # ---正在吃---
lisi.staticRun()  # ---正在跑---
```

由以上代码可知，通过[**类名.静态方法名**]给类Person动态添加了静态方法staticRun()，Person类的Person的类对象zhangsan和lisi都能调用这个方法 

**注：通过类名添加的静态方法，这个类及这个类的所有对象都能使用**

## @property（属性方法装饰器）

属性方法应用场景： 

好吧，把一个方法变成静态属性有什么卵用呢？既然想要静态变量，那直接定义成一个静态变量不就得了么？well, 以后你会需到很多场景是不能简单通过 定义 静态属性来实现的， 比如 ，你想知道一个航班当前的状态，是到达了、延迟了、取消了、还是已经飞走了， 想知道这种状态你必须经历以下几步:

1. 连接航空公司API查询

2. 对查询结果进行解析 

3. 返回结果给你的用户

 因此这个status属性的值是一系列动作后才得到的结果，所以你每次调用时，其实它都要经过一系列的动作才返回你结果，但这些动作过程不需要用户关心， 用户只需要调用这个属性就可以，明白 了么？

```python
class Flight(object):
    def __init__(self,name):
        self.flight_name = name


    def checking_status(self):
        print("checking flight %s status " % self.flight_name)
        return  1

    @property
    def flight_status(self):
        status = self.checking_status()
        if status == 0 :
            print("flight got canceled...")
        elif status == 1 :
            print("flight is arrived...")
        elif status == 2:
            print("flight has departured already...")
        else:
            print("cannot confirm the flight status...,please check later")


f = Flight("CA980")
f.flight_status
```

**扩展：**

使用上面的方法创建的属性我们无法修改，如果修改的话我们需要使用下面的方式再次创建对应的方法实现：

```python
class Flight(object):
    def __init__(self,name):
        self.flight_name = name


    def checking_status(self):
        print("checking flight %s status " % self.flight_name)
        return  1


    @property
    def flight_status(self):
        status = self.checking_status()
        if status == 0 :
            print("flight got canceled...")
        elif status == 1 :
            print("flight is arrived...")
        elif status == 2:
            print("flight has departured already...")
        else:
            print("cannot confirm the flight status...,please check later")
    
    @flight_status.setter #修改
    def flight_status(self,status):
        status_dic = {
            0 : "canceled",
            1 :"arrived",
            2 : "departured"
        }
        print("\033[31;1mHas changed the flight status to \033[0m",status_dic.get(status) )

    @flight_status.deleter  #删除
    def flight_status(self):
        print("status got removed...")

f = Flight("CA980")
f.flight_status
f.flight_status =  2 #触发@flight_status.setter 
del f.flight_status #触发@flight_status.deleter 
```

## 运算符重载

Python不会限制操作符重载算术运算符。也可以重载比较运算符。

 下面的示例实现了在`Point`自定义类中实现小于符号`<`比较运算。比较这些来自原点的数值，并为此返回结果。 可以实现如下。 

```python
class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def __str__(self):
        return "({0},{1})".format(self.x,self.y)

    def __lt__(self,other):
        self_mag = (self.x ** 2) + (self.y ** 2)
        other_mag = (other.x ** 2) + (other.y ** 2)
        return self_mag < other_mag

```

在Python shell中尝试这些示例运行。

```python
>>> Point(1,1) < Point(-2,-3)
True

>>> Point(1,1) < Point(0.5,-0.2)
False

>>> Point(1,1) < Point(1,1)
False
```

## 发邮件与发短信

### 邮件发送

​	简介：
​	邮件服务器、账户、密码
​	相关协议：SMTP、POP3、IMAP
​	默认TCP协议端口：25
​	用途：经常用在一个网站的注册激活、通知、找回密码等场景
​	库：smtplib
示例：

```python
import os
import smtplib
# 用于邮件发送的类
from email.mime.text import MIMEText
# 邮箱服务器
mail_server = 'smtp.163.com'
# 用户名
mail_user = 'xxx@163.com'
# 密码或授权码
# 为了密码不对外公开，可以通过环境变量进行获取
mail_pwd = os.getenv('MAIL_PASSWORD', '123456')
# 消息内容
content = '请点击右边链接完成激活，激活'
# 创建消息对象，并设置内容，
# 第二个用于指定文本内容类型，若不指定默认是文本
message = MIMEText(content, 'html')
# 设置主题
message['Subject'] = '账户激活'
# 设置发送者
message['From'] = mail_user
# 创建邮件发送类
mail = smtplib.SMTP(mail_server, 25)
# 身份认证
mail.login(mail_user, mail_pwd)
# 指定接收者，多个接收者使用列表
to = 'xxx@qq.com'
# 发送邮件
mail.sendmail(mail_user, to, message.as_string())
# 结束
mail.quit()
```

### 短信发送

在当前的潮流下似乎一个网站或者一个什么系统不用短信验证一下自己的用户身份已经是一个很low的事情了，不过短信的发送我们还是需要借助第三方平台来实现的，下面我们就通过互亿无线提供的短信发送平台实现以下短信的发送。其官方网站为：http://www.ihuyi.com/

1.在互亿无线注册用户。
2.在短信验证获取APIid以及APIpasswd
3.文档中心下载Api接口后通过解压打开Demo
4.找到自己需要的语言源码通过记事本打开
5.将源码复制到编译器
修改httplib为http.client
urllib.urlencode修改为urllib.parse.urlencode
account修改为APIID,password修改为APIpasswd
mobile：修改为需要发送的电话号码

修改text里的数字验证码为自己需要的

```python
import http.client
from urllib import parse

host  = "106.ihuyi.com"
sms_send_uri = "/webservice/sms.php?method=Submit"

#用户名是登录用户中心->验证码短信->产品总览->APIID
account  = APIID           # 登陆自己的账号获取
#密码 查看密码请登录用户中心->验证码短信->产品总览->APIKEY
password = APIKEY          # 登陆自己的账户获取

def send_sms(text, mobile):
    params = parse.urllib.parse.urlencode({'account': account, 'password' : password, 'content': text, 'mobile':mobile,'format':'json' })####
    headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"}
    conn = http.client.HTTPConnection(host, port=80, timeout=30)####
    conn.request("POST", sms_send_uri, params, headers)
    response = conn.getresponse()
    response_str = response.read()
    conn.close()
    return response_str

if __name__ == '__main__':

    mobile = "180****0799"          # 要发送验证码的手机号
    text = "您的验证码是："+ mobile[7:] +"。请不要把验证码泄露给其他人。"     
　　# 短信内容的模板必须和后台定义的一样，

    print(send_sms(text, mobile))
```



## 练习：银行自动提款机系统案例实战

**提示：对象分析**

**用户**

类名：User
属性：姓名、身份证号码、电话号码、卡
行为：查询、取款、存款、转账、改密

**卡**

类名：Card
属性：卡号 密码 余额
行为：

**提款机**

类名：ATM
属性：用户字典
行为：开户、查询、取款、存款、转账、改密、锁定、解锁、补卡、销户

**管理员**

类名：Admin
属性：
行为：管理员界面、管理员验证、系统功能界面

# 第四天：文件操作与异常处理

>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。
比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。
IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。
由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：
第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。
同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。
你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。
很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。

## stringIO与bytesIO

很多时候，数据读写不一定是文件，也可以在内存中读写。

StringIO顾名思义就是在内存中读写str。

要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可： 

```
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())
hello world!
```

`getvalue()`方法用于获得写入后的str。

 要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：

```
>>> from io import StringIO
>>> f = StringIO('Hello!\nHi!\nGoodbye!')
>>> while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
```

StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。

BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：

```
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
```

请注意，写入的不是str，而是经过UTF-8编码的bytes。 

和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：

```python
>>> from io import BytesIO
>>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
>>> f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
```

## 文件的管理操作

读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 

读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。

### 读文件

要以读文件的模式打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符：

```
>>> f = open('/Users/michael/test.txt', 'r')
```

标示符'r'表示读，这样，我们就成功地打开了一个文件。

如果文件不存在，`open()`函数就会抛出一个`IOError`的错误，并且给出错误码和详细的信息告诉你文件不存在：

```
>>> f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
```

如果文件打开成功，接下来，调用`read()`方法可以一次读取文件的全部内容，Python把内容读到内存，用一个`str`对象表示：

```
>>> f.read()
'Hello, world!'
```

最后一步是调用`close()`方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：

```
>>> f.close()
```

由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用`try ... finally`来实现： 

```
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

但是每次都这么写实在太繁琐，所以，Python引入了`with`语句来自动帮我们调用`close()`方法： 

```
with open('/path/to/file', 'r') as f:
    print(f.read())
```

这和前面的`try ... finally`是一样的，但是代码更佳简洁，并且不必调用`f.close()`方法。

调用`read()`会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用`read(size)`方法，每次最多读取size个字节的内容。另外，调用`readline()`可以每次读取一行内容，调用`readlines()`一次读取所有内容并按行返回`list`。因此，要根据需要决定怎么调用。

 如果文件很小，`read()`一次性读取最方便；如果不能确定文件大小，反复调用`read(size)`比较保险；如果是配置文件，调用`readlines()`最方便：

```
for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
```

### file-like Object 

像`open()`函数返回的这种有个`read()`方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个`read()`方法就行。 

`StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。 

| 序号 | 方法|描述                                                   |
| ---- | ---|---------------------------------------------------- |
| 1    | file.close()|关闭文件。关闭后文件不能再进行读写操作。 |
| 2    | file.flush()|刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 |
| 3    | file.fileno()|返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |
| 4    | file.isatty()]|如果文件连接到一个终端设备返回 True，否则返回 False。 |
| 5    | file.next()|返回文件下一行。 |
| 6    | file.read([size\])|从文件读取指定的字节数，如果未给定或为负则读取所有。 |
| 7    | file.readline([size\])|读取整行，包括 "\n" 字符。 |
| 8    | file.readlines([sizeint\])|读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 |
| 9    | file.seek(offset[, whence\])|设置文件当前位置 |
| 10   | file.tell()|返回文件当前位置。 |
| 11   | file.truncate([size\])|从文件的首行首字符开始截断，截断文件为 size  个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。 |
| 12   | file.write(str)|将字符串写入文件，返回的是写入的字符长度。 |
| 13   | file.writelines(sequence)|向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |

### 二进制文件 

前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用`'rb'`模式打开文件即可：

```
>>> f = open('/Users/michael/test.jpg', 'rb')
>>> f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
```

### 字符编码

要读取非UTF-8编码的文本文件，需要给`open()`函数传入`encoding`参数，例如，读取GBK编码的文件： 

```
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
>>> f.read()
'测试'
```

遇到有些编码不规范的文件，你可能会遇到`UnicodeDecodeError`，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，`open()`函数还接收一个`errors`参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略： 

```
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
```

### 写文件

写文件和读文件是一样的，唯一区别是调用`open()`函数时，传入标识符`'w'`或者`'wb'`表示写文本文件或写二进制文件：

```
>>> f = open('/Users/michael/test.txt', 'w')
>>> f.write('Hello, world!')
>>> f.close()
```

你可以反复调用`write()`来写入文件，但是务必要调用`f.close()`来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用`close()`方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用`close()`的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用`with`语句来得保险：

```
with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
```

要写入特定编码的文本文件，请给`open()`函数传入`encoding`参数，将字符串自动转换成指定编码。细心的同学可能会发现，以`'w'`模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入`'a'`以追加（append）模式写入。

## 文件的读写（csv、txt）操作

逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列.

### 特点

- 读取出的数据一般为字符类型，如果是数字需要人为转换为数字
- 以行为单位读取数据
- 列之间以半角逗号或制表符为分隔，一般为半角逗号
- 一般为每行开头不空格，第一行是属性列，数据列之间以间隔符为间隔无空格，行之间无空行。

## with上下文处理

在了解with语句之前我们先回想一下我们打开文件的操作：

```python
f = open("test.txt")
try:
    for line in f.readlines():
        print(line)
finally:
    f.close()
```

with语句的基本语法结构如下:　　　

```python
with expression [as variable]:
　　　 with-block
```

先看下如果用with语句代替上面的try/finally的例子，然后再讨论它的更多细节，如下

```python
with open("text.txt") as f:
    for line in f.readlines()
　　　　print(line)
```

 是不是发现使用with语句相对try/finally来说简洁了很多，而且也不需要每一个用户都去写f.close()来关闭文件了，这是因为with语句在背后做了大量的工作。with语句的expression是上下文管理器，这个我们下文会说。with语句中的[as variable]是可选的，如果指定了as variable说明符，则variable是上下文管理器expression调用__enter__()函数返回的对象。所以，f并不一定就是expression，而是expression.__enter__()的返回值，至于expression.__enter__()返回什么就由这个函数来决定了。with-block是执行语句，with-block执行完毕时，with语句会自动进行资源清理，对应上面例子就是with语句会自动关闭文件。

下面我们来具体说下with语句在背后默默无闻地到底做了哪些事情。刚才我们说了expression是一个上下文管理器，其实现了__enter__和__exit__两个函数。当我们调用一个with语句时，执行过程如下： 

1. 首先生成一个上下文管理器expression，在上面例子中with语句首先以“test.txt”作为参数生成一个上下文管理器open("test.txt")。

2. 然后执行expression.__enter__()。如果指定了[as variable]说明符，将__enter__()的返回值赋给variable。上例中open("test.txt").__enter__()返回的是一个文件对象给f。

3. 执行with-block语句块。上例中执行读取文件。 

4. 执行expression.__exit__(),在__exit__()函数中可以进行资源清理工作。上面例子中就是执行文件的关闭操作。

在上文中我们提到with语句中的上下文管理器。with语句可以如此简单但强大，主要依赖于上下文管理器。那么什么是上下文管理器?上下文管理器就是实现了上下文协议的类，而上下文协议就是一个类要实现__enter__()和__exit__()两个方法。一个类只要实现了__enter__()和__exit__()，我们就称之为上下文管理器下面我们具体说下这两个方法。

 **__enter__()**：主要执行一些环境准备工作，同时返回一资源对象。如果上下文管理器open("test.txt")的__enter__()函数返回一个文件对象。

**__exit__()**：完整形式为__exit__(type, value, traceback),这三个参数和调用sys.exec_info()函数返回值是一样的，分别为异常类型、异常信息和堆栈。如果执行体语句没有引发异常，则这三个参数均被设为None。否则，它们将包含上下文的异常信息。\_\_exit\_\_()方法返回True或False,分别指示被引发的异常有没有被处理，如果返回False，引发的异常将会被传递出上下文。如果\_\_exit\_\_()函数内部引发了异常，则会覆盖掉执行体的中引发的异常。处理异常时，不需要重新抛出异常，只需要返回False，with语句会检测\_\_exit\_\_()返回False来处理异常。



# 第五天：案例实战

## 英汉词典

功能说明 ： 

1. 用户能够登录注册   登录凭借用户名和密码即可  注册 要求用户名和密码 要求用户名不能重复

2. 用户信息需要长期保存   使用csv格式文件存储

3. 要求能够满足多用户同时登录操作的情况

4. 用户开启客户端即进入 登录 注册  退出 界面

5. 用户登录后即进入用户的 查词  查看历史记录  退出界面   

   查词 ： 英英词典  可以循环查询  查一个词会反馈给客户端词义   

   历史记录 ： 查看自己曾经的查词记录  返回给用户查过哪些词 ，用户名， 什么时间差的

   退出 ： 退到上一级界面

6. 单词词义从单词本获取 * 每个单词占一行 * 单词和解释之间有空格 * 单词按顺序排列

## 歌词解析器

使用pygame模块及pyqt5实现一个简单的音乐播放器，可以实现歌词显示、上一首、下一首、退出、播放、暂停、音乐列表显示等功能。

pygame音频相关参考代码：

```python
""" pygame 
-- 音乐 常用方法 
pygame.init() 进行全部模块的初始化， 
pygame.mixer.init() 或者只初始化音频部分 
pygame.mixer.music.load('xx.mp3') 使用文件名作为参数载入音乐 ,音乐可以是ogg、mp3等格式。载入的音乐不会全部放到内容中，而是以流的形式播放的，即在播放的时候才会一点点从文件中读取。 
pygame.mixer.music.play()播放载入的音乐。该函数立即返回，音乐播放在后台进行。 play方法还可以使用两个参数 pygame.mixer.music.play(loops=0, start=0.0) loops和start分别代表重复的次数和开始播放的位置。 
pygame.mixer.music.stop() 停止播放， 
pygame.mixer.music.pause() 暂停播放。 
pygame.mixer.music.unpause() 取消暂停。 
pygame.mixer.music.fadeout(time) 用来进行淡出，在time毫秒的时间内音量由初始值渐变为0，最后停止播放。 
pygame.mixer.music.set_volume(value) 来设置播放的音量，音量value的范围为0.0到1.0。 
pygame.mixer.music.get_busy() 判断是否在播放音乐,返回1为正在播放。 
pygame.mixer.music.set_endevent(pygame.USEREVENT + 1) 在音乐播放完成时，用事件的方式通知用户程序， 设置当音乐播放完成时发送pygame.USEREVENT+1事件给用户程序。 
pygame.mixer.music.queue(filename) 使用指定下一个要播放的音乐文件， 当前的音乐播放完成后自动开始播放指定的下一个。一次只能指定一个等待播放的音乐文件。 
""" 
```

# 附录：

## 类专有方法一览表

**\*\*基本定制方法**

| 特殊方法                      | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| C.__init__(self[, arg1, ...]) | 构造器（带一些可选的参数）                                   |
| C.__new__(self[, arg1, ...])  | 构造器（带一些可选的参数）；通常用在设置不变数据类型的子类。 |
| C.__del__(self)               | 解构器                                                       |
| C.__str__(self)               | 可打印的字符输出；内建str()及print 语句                      |
| C.__repr__(self)              | 运行时的字符串输出；内建repr() 和‘‘ 操作符                   |
| C.__unicode__(self)           | b Unicode 字符串输出；内建unicode()                          |
| C.__call__(self, *args)       | 表示可调用的实例                                             |
| C.__nonzero__(self)           | 为object 定义False 值；内建bool() （从2.2 版开始）           |
| C.__len__(self)               | “长度”（可用于类）；内建len()                                |

特殊定制方法

| 对象（值）                               | 比较c 说明                           |
| ---------------------------------------- | ------------------------------------ |
| C.__cmp__(self, obj)                     | 对象比较；内建cmp()                  |
| C.__lt__(self, obj)\|C.__le__(self, obj) | and 小于/小于或等于；对应<及<=操作符 |
| C.__gt__(self, obj)\|C.__ge__(self, obj) | and 大于/大于或等于；对应>及>=操作符 |
| C.__eq__(self, obj)\|C.__ne__(self, obj) | and 等于/不等于；对应==,!=及<>操作符 |

属性定制方法

| 对象（值）                     | 说明                                            |
| ------------------------------ | ----------------------------------------------- |
| C.__getattr__(self, attr)      | 获取属性；内建getattr()；仅当属性没有找到时调用 |
| C.__setattr__(self, attr, val) | 设置属性                                        |
| C.__delattr__(self, attr)      | 删除属性                                        |
| C.__getattribute__(self, attr) | 获取属性；内建getattr()；总是被调用             |
| C.__get__(self, attr)          | （描述符）获取属性                              |
| C.__set__(self, attr, val)     | （描述符）设置属性                              |
| C.__delete__(self, attr)       | （描述符）删除属性                              |

定制类/模拟类型

| 数值类型：              | 二进制操作符      |
| ----------------------- | ----------------- |
| C.__rshift__(self, obj) | 右移；>>操作符    |
| C.__and__(self, obj)    | 按位与；&操作符   |
| C.__or__(self, obj)     | 按位或；          |
| C.__xor__(self, obj)    | 按位与或；^操作符 |

| **数值类型**       | 一元操作符        |
| ------------------ | ----------------- |
| C.__neg__(self)    | 一元负            |
| C.__pos__(self)    | 一元正            |
| C.__abs__(self)    | 绝对值；内建abs() |
| C.__invert__(self) | 按位求反；~操作符 |

| **数值类型**       | 二元操作符        |
| ------------------ | ----------------- |
| C.__add__(self,obj)    | 加法运算 +           |
| C.__sub__(self,obj)    | 减法运算 -           |
| C.__mul__(self,obj)    | 乘法运算 *|
| C.__pow__(self,obj) | 幂运算 ** |
| C.__truediv__(self,obj)    | 除法运算/            |
| C.__floordiv__(self,obj)    | 地板除法//|
| C.__mod__(self,obj) | 取模运算% |

| 数值类型：               | 数值转换                        |
| ------------------------ | ------------------------------- |
| C.__complex__(self, com) | 转为complex(复数);内建complex() |
| C.__int__(self)          | 转为int;内建int()               |
| C.__long__(self)         | 转为long；内建long()            |
| C.__float__(self)        | 转为float；内建float()          |

| 数值类型：      | 基本表示法（String）    |
| --------------- | ----------------------- |
| C.__oct__(self) | 八进制表示；内建oct()   |
| C.__hex__(self) | 十六进制表示；内建hex() |

| 数值类型                | 数值压缩                                                     |
| ----------------------- | ------------------------------------------------------------ |
| C.__coerce__(self, num) | 压缩成同样的数值类型；内建coerce()                           |
| C.__index__(self)       | g 在有必要时,压缩可选的数值类型为整型（比如：用于切片索引等等 |

**序列类型**

| 特殊方法                         | 描述                          |
| -------------------------------- | ----------------------------- |
| C.__len__(self)                  | 序列中项的数目                |
| C.__getitem__(self, ind)         | 得到单个序列元素              |
| C.__setitem__(self, ind,val)     | 设置单个序列元素              |
| C.__delitem__(self, ind)         | 删除单个序列元素              |
| C.__getslice__(self, ind1,ind2)  | 得到序列片断                  |
| C.__setslice__(self, i1, i2,val) | 设置序列片断                  |
| C.__delslice__(self, ind1,ind2)  | 删除序列片断                  |
| C.__contains__(self, val)        | f 测试序列成员；内建in 关键字 |
| C.__add__(self,obj)              | 串连；+操作符                 |
| C.__mul__(self,obj)              | 重复；*操作符                 |
| C.__iter__(self)                 | 创建迭代类；内建iter()        |

**映射类型**

| 特殊方法                    | 描述                                     |
| --------------------------- | ---------------------------------------- |
| C.__len__(self)             | mapping 中的项的数目                     |
| C.__hash__(self)            | 散列(hash)函数值                         |
| C.__getitem__(self,key)     | 得到给定键(key)的值                      |
| C.__setitem__(self,key,val) | 设置给定键(key)的值                      |
| C.__delitem__(self,key)     | 删除给定键(key)的值                      |
| C.__missing__(self,key)     | 给定键如果不存在字典中，则提供一个默认值 |

可以使用with关键字的类型，需要实现：
__enter__ 和 __exit__
iterator迭代器对象必须实现：

__iter__ 和 next()



