# 第一天：编程导论及环境创建

## 认识计算机

计算机是什么？？？
![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/jsj.jpg)
计算机组成结构了解
![jsjjg](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/jsjjg.png)
计算机运行原理了解
![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/jsjyxyl.jpg)

## 机器数与码制

### 机器码认识

各种数据在计算机中表示的形式称为机器数，其特点是采用二进制计数制，数的符号用0、1表示，小数点则隐含表示而不占位置。机器数对应的实际数值称为真值。
机器数有无符号数和带符号数之分。无符号数表示正数，在机器数中没有符号位。对于无符号数，若约定小数点的位置在机器数的最低位之后，则是纯整数；若约定小数点的位置在机器数的最高位之前，则是纯小数。对于带符号数，机器数的最高位一晴地正负的符号位，其余位则表示数值。若约定小数点的位置在机器数的最低数值位之后，则是纯整数；若约定小数点的位置 在机器数的最高数值位之前，则是纯小数位。

为了便于运算，带符号的机器右数可采用原码，反码和补码等不同的编码方法，机器数的这些编码方法称为码制。

1. 原码表示法
   数值X的原码记为[X]原，最高位是符号位，0表示正号，1表示负号，其余位表示数值的绝对值。
2. 反码表示法
   数值X的原码记为[X]反，最高位是符号位，0表示正号，1表示负号，正数的反码和原码相同，负数的反码则是其绝对值按位求反。
3. 补码表示法
   数值X的原码记为[X]补，最高位是符号位，0表示正号，1表示负号，正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。
4. 移码表示法
   移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。如果机器字长为n，在偏移2的（n-1）次方的情况下，只要将将码的符号位取反便可获得相应的移码表示。

### *码制转换

0进制转换成其他的都是除以要转换成的那个数，也就是说转换成二进制的就除以2，转换成八进制的就除以8，转换成十六进制的就除以16，然后倒取余数。
不同的进位制数转化为十进制数：按权展开相加。十进制是权是10；二进制是权是2；十六进制是权是16；八进制是权是8；

例：110011(二进制数)=1*2^5+1*2^4+0*2^3+0*2^2+1*2^1+1*2^0=32+16+2+1=51
1507(八进制数)=1*8^3 + 5*8^2 + 0*8^1 + 7*8^0 = 839 
2AF5（十六进制数）=2*16^3 + A*16^2+ F*16^1 + 5*16^0 = 10997
二进制换算八进制 
将二进制数从右到左，三位一组，不够补0

例：二进制数10110111011换八进制数： 
010 110 111 011 
结果为：2673 
二进制转换十六进制 
二进制数转换为十六进制数的方法也类似，从右到左，四位一组，不够补0
如上题： 
0101 1011 1011 
结果为：5BB

### *字符编码

#### 为什么需要字符编码？？？

我们知道，所有的信息最终都表示为一个二进制的字符串，每一个二进制位（bit）有0和1两种状态。当我们需要把字符'A'存入计算机时，应该对应哪种状态呢，存储时，我们可以将字符'A'用01000010（这个随便编的）二进制字符串表示，存入计算机；读取时，再将01000010还原成字符'A'。那么问题来了，存储时，字符'A'应该对应哪一串二进制数呢，是01000010？或者是10000000 11110101？说白了，就是需要一个规则。这个规则可以将字符映射到唯一一种状态(二进制字符串)，这就是编码。而最早出现的编码规则就是ASCII编码，在ASCII编码规则中，字符'A'既不对应01000010，也不对应1000 0000 11110101，而是对应01000001（不要问为什么，这是规则）。

#### 字符编码介绍：

1. **ASCII**

   这套编码规则是由美国定制，一共规定了128个字符的编码，比如空格"SPACE"是32（十进制）（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括 32个不能打印出来的控制符号），只占用了一个字节（8 bit）的后面7位，最前面的1位统一规定为0。总共才有128个字符编码，一个字节都没有用完，这好像似乎有点太少了。于是乎，就开始压榨最高位，对其为1时也进行编码，利用最高位进行编码的方式就称为非ASCII编码，如ISO-8859-1编码。

   ![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/ascii.jpg)

2. **ISO-8859-1**

   这套编码规则由ISO组织制定。是在 ASCII 码基础上又制定了一些标准用来扩展ASCII编码，即 00000000（0） ~ 01111111（127） 与ASCII的编码一样，对 10000000（128） ~ 11111111（255）这一段进行了编码，如将字符§编码成 10100111（167）。ISO-8859-1编码也是单字节编码，最多能够表示256个字符。Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。但是，即使能够表示256个字符，对中文而言，还是太少了，一个字节肯定不够，必须用多个字节表示。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 ISO8859-1编码来表示。而且在很多协议上，默认使用该编码。比如，虽然"中文"两个字不存在ISO8859-1编码，以GB2312编码为例，应该是D6D0 CEC4两个字符，使用ISO8859-1编码的时候则将它拆开为4个字节来表示：D6D0 CEC4（事实上，在进行存储的时候，也是以字节为单位进行处理）。而如果是UTF编码，则是6个字节e4 b8 ad e6 96 87。很明显，这种表示方法还需要以另一种编码为基础才能正确显示。而常见的中文编码方式有GB2312、BIG5、GBK。

3. **GB2312**

   GB2312其对所收录字符进行了"分区"处理，共94个区，区从1（十进制）开始，一直到94（十进制），每区含有94个位，位从1（十进制）开始，一直到94（十进制），共8836（94 * 94）个码位，这种表示方式也称为区位码，GB2312是双字节编码，其中高字节表示区，低字节表示位。

   GB2312用两个字节编码，采用分区编码，总共编码的中文个数为6763（3755 + 3008）。这些汉字只是最常用的汉字，已经覆盖中国大陆99.75%的使用频率。但是，还有一些汉字在GB2312中没有被编码，如'镕'字，在GB2312中就没有被编码，这样就导致了问题，随之就出现了主流的GBK编码。

   **小知识**：GB2312编码规则

   各区具体说明如下：

   01-09区收录除汉字外的682个字符，有164个空位（9 * 94 - 682）。
   10-15区为空白区，没有使用。
   16-55区收录3755个一级汉字（简体），按拼音排序。
   56-87区收录3008个二级汉字（简体），按部首/笔画排序。
   88-94区为空白区，没有使用。

   那么根据区位码如何算出GBK2312编码呢？区位码的表示范围为0101 - 9494（包含了空的区位码）。点击这里，查看中GB2312编码区位码。之后只需要按照如下规则进行转化即可。

   1. 将区（十进制）转化为十六进制。
   2. 将转化的十六进制加上A0，得到GB2312编码的高字节。
   3. 将位（十进制）转化为十六进制。
   4. 将转化的十六进制加上A0，得到GB2312编码的低字节。
   5. 组合区和位，区在高字节，位在低字节。
   6. 得到GB2312编码。

   例如：'李'字的区位码为3278（表示在32区，78位）。

   1. 将32（区）转化为十六进制为20。
   2. 加上A0为C0。3. 将78（位）转化为十六进制为4E。
   3. 加上A0为EE。
   4. 组合区和位，为C0EE。
   5. 得到GB2312编码，即'李'字的GB2312编码为C0EE。

4. **GBK**

   GBK编码扩展了GB2312，完全兼容GB2312编码（如'李'字的GBK、GB2312编码均为C0EE），但其不兼容BIG5编码（'長'字的BIG5编码为AAF8，GBK编码为E94C，'李'字的BIG5编码为A7F5 不等于C0EE），即如果使用GB2312编码，使用GBK解码是完全正常的，但是如果使用BIG5编码，使用GBK解码，会出现乱码。相比于GB2312编码，GBK编码了更多汉字，如'镕'字。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。能表示 21003 个汉字。点击这里，查看GBK编码。点击这里，可以查询中文的其他编码。在GBK之后又出现了GB18030编码，但是没有形成主流，故不做介绍，至此，中文编码的问题已经讲解完成。那么问题又来了，大陆网民与在海峡两岸网民交流时，若都使用GBK编码，则没有问题，若一方使用GBK编码，一方使用BIG5编码，那么就会出现乱码问题，这是在海峡两岸网民交流，如果漂洋过海进行交流呢？那就更容易出现乱码问题，这时候我们可能想，要是有一套全世界都通用的编码就好了，不要担心，这样的编码确实是存在的，那就是Unicode。

5. **BIG5（大五码）**

   BIG5采用双字节编码，使用两个字节来表示一个字符。高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE。该编码是繁体中文字符集编码标准，共收录13060个中文字，其中有二字为重复编码，即“兀、兀”（A461及C94A)和“嗀、嗀”(DCD1及DDFC)。具体的分区如下：　

   1. 8140-A0FE 保留给使用者自定义字符（造字区） 

   2. A140-A3BF 标点符号、希腊字母及特殊符号。

      其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。
      A3C0-A3FE 保留。此区没有开放作造字区用。
      A440-C67E 常用汉字，先按笔划再按部首排序。
      C6A1-F9DC 其它汉字。
       F9DD-F9FE 制表符。

   **注意：**BIG5编码与GBK编码没有什么关系。

6. **Unicode**

   有两个独立的, 创立单一字符集的尝试. 一个是国际标准化组织(ISO)的 ISO 10646 项目, 另一个是由多语言软件制造商组成的协会组织的 Unicode 项目. 在1991年前后, 两个项目的参与者都认识到, 世界不需要两个不同的单一字符集. 它们合并双方的工作成果, 并为创立一个单一编码表而协同工作. 两个项目仍都存在并独立地公布各自的标准, 但 Unicode 协会和 ISO/IEC JTC1/SC2 都同意保持 Unicode 和 ISO 10646 标准的码表兼容, 并紧密地共同调整任何未来的扩展。

   Unicode是指一张表，里面包含了可能出现的所有字符，每个字符对应一个数字，这个数字称为码点(Code Point)，如字符'H'的码点为72（十进制），字符'李'的码点为26446（十进制）。Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制）。地球上所有字符都可以在Unicode表中找到对应的唯一码点。点击这里，查询字符对应的码点。Unicode将码空间划分为17个平面，从00 - 10（十六进制，最高两位），即从0 - 16（十进制），每个平面有65536个码点（2^16），其中最重要的是第一个Unicode平面(码位从0000 - FFFF)，包含了最常用的字符，该平面被称为基本多语言平面（Basic Multilingual Plane），缩写为BMP，其他平面称为辅助平面(Supplementary Planes)，在基本多文种平面內， 从D800到DFFF之间的码位区段是永久保留不映射到字符的， 因此UTF-16编码巧妙的利用了这保留下来的码位来对辅助平面内的字符进行编码，这点后面进行讲解。Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储，如何进行存储出现了不同的编码方案，关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。

7. **UTF-8**

   UTF-8是一种变长编码方式，使用1-4个字节进行编码。UTF-8完全兼容ASCII，对于ASCII中的字符，UTF-8采用的编码值跟ASCII完全一致。UTF-8是Unicode一种具体的编码实现。UTF-8是在互联网上使用最广的一种Unicode的编码规则，因为这种编码有利于节约网络流量（因为变长编码，而非统一长度编码）。关于Unicode码点如何转化为UTF-8编码，可以参照如下规则：

   　　① 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。

   　　② 对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

   总结的编码规则如下：

| Unicode符号范围(十六进制) (十进制)  | UTF-8编码方式（二进制）             |
| ----------------------------------- | ----------------------------------- |
| 0000 0000-0000 007F (0-127)         | 0xxxxxxx                            |
| 0000 0080-0000 07FF (128-2047)      | 110xxxxx 10xxxxxx                   |
| 0000 0800-0000 FFFF (2048-65535)    | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000-0010 FFFF (65536-1114111) | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

说明：字符'A'的Unicode码点为65（十进制），根据上表，在第一行范围，则字符'A'的UTF-8编码为01000001，中文字符'李'的Unicode码点为26446（十进制），二进制为01100111 01001110，十六进制为674E。根据上表，在第三行范围，则将'李'二进制代码从低位到高位依次填入x中，不足的填入0。得到UTF-8编码为11100110 10011101 10001110，即E69D8E（十六进制）。

由上述编码规则可知，0000 0000 - 0000 FFFF（第一行到第三行）为Unicode第一个平面（基本多语言平面），而0001 0000 - 10 FFFF（第四行）为Unicode其他平面（辅助平面）。在基本多语言平面对应了绝大多数常用的字符。对于大于65535（十进制）的码点，即在辅助平面上的码点，需要使用4个字节来进行UTF-8编码。

字符编码在Python中也是一个重要的概念，通常我们有可能因为脚本保存编码与生命编码不一致导致程序运行错误。

## 编程语言认识

### 语言发展史

计算机语言总的来说分为机器语言，汇编一语言，高级语言三大类。而这三种语言也恰恰是计算机语言发展历史的三个阶段。

1946年2月14日，世界上第一台计算机ENIAC诞生，使用的是最原始的穿孔卡片。这种卡片上使用的语言是只有专家才能理解的语言，与人类语言差别极大，这种语言就称为机器语言。机器语言是第一代计算机语言。这种语言本质上是计算机能识别的唯一语言，人类很难理解。以后的语言就是在这个的基础上简化而来。虽然后来发展的语言能让人类直接理解但最终送入计算机的还是这种机器语言。

计算机语言发展到第二代，出现了汇编语言。汇编语言用助记符代替了操作码。用地址符号或标号代替地址码。这样就用符号代替了机器语言的二进制码。汇编语言也称为符号语言。 比起机器语言，汇编大大进步了。尽管还是复杂，用起来容易出错，但在计算机语言发展史上是机器语言像更高级的语言进化的桥梁。

当计算机语言发展到第三代时，就进入了“面向人类”的高级语言 。高级语言是一种接近于人们使用习惯的程序设计语言。它允许用英文写计算程序，程序中得符号和式子也与日常用的数学式子差不多。高级语言发展于上世纪50年代中叶到70年代，流行的高级语言已经开始固化在计算机内存里了。比如basic语言。

现在，计算机语言仍然在不断的发展，种类也相当多，比如：
FORTRAN语言，COBOL语言，C语言，C++，PASCAC，JAVA等等。

### 语言分类

![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/yyfl.png)
由发展阶段划分为：低级语言、高级语言
由程序运行方式分为：解释型语言、编译型语言
由编程思想划分为：面向对象语言、面向过程语言
由变量实现类型划分为：动态语言、静态语言

## 如何编程

![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/bclc.jpg)

## 如何学习

记住最重要的是**保持热情、保持热情、保持热情... ...**
坚持是你最大的成就。
关键字周期性记忆（1、1、3、7、10、15）：使用练习本抄写，早读背诵，小组默写。
课堂代码反复练习
按时完成作业
成立学习小组互相讨论分享
每周总结，写技术博客文档
扩展思考，动手实践

## 环境搭建

### ubuntu下的python安装

**1 修改Ubuntu软件源**

Ubuntu安装好之后，安装软件源的服务器地址在境外，速度会比较慢，因此建议修改软件源为国内镜像，这样安装和更新软件会更快些，此处使用的是清华大学开源软件镜像。

1.1 备份原有软件源列表

```shell
`sudo` `cp` `/etc/apt/sources``.list ``/etc/apt/sources``.list_backup`
```

1.2 修改软件源为国内镜像

用编辑器打开/etc/apt/source.list

```shell
sudo vi /etc/apt/sources.list
```

而后将文件内原有内容清空，复制以下内容

```shell
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
```

**2 更新软件**

更新ubuntu软件列表

```shell
sudo apt-get update
```

更新本地软件

```shell
sudo apt-get upgrade
```

**3 python开发环境安装**

安装python3

```shell
sudo apt-get install python3
```

安装python3-dev

```shell
sudo apt-get install python3-dev
```

查看python3版本

```shell
python3 -V
```

安装pip3

```shell
sudo apt-get install python3-pip
```

安装ipython3交互环境

```shell
pip3 install ipython
```

安装spyder编辑器

```shell
pip3 install spyder
```

## 附录扩展：（ubuntu安装）

**注意：**因为硬件系统的原因，本方法可能无法适用于所有人。系统安装有风险，请在安装之前备份重要数据。本步骤仅供参考。

### 工具准备

1. 能上网的电脑一台。
2. 8GU盘一个。（注意：U盘里千万不要存重要文件，后面会对U盘进行清空）

### 制作Ubuntu系统U盘启动工具

1. 下载制作安装盘的软件 rufus (ps:若是 UEFI 的启动方式，建议使用 rufus 制作安装)

链接：<http://rufus.akeo.ie/>

![img](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%86%85%E5%AE%B9.assets/clip_image002.jpg)

图 3 软件下载位置

1. 在官网下载 18.04 的镜像 iso 到本地；

链接：https://www.ubuntu.com/download/desktop

1. 打开 rufus，如所示；先在红色方框所标识的地方处，选择镜像 iso：

![img](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%86%85%E5%AE%B9.assets/clip_image004.jpg)

图 4 rufus界面

然后需要根据具体需要，对“分区方案和目标系统类型”进行选择，以下为各选项含义:

“MBR 分区方案用户 BIOS 或 UEFI 的计算机”: 硬盘为 MBR 分区格式, 则可选择此项,但是如果你有一个 UEFI 的计算机,最好选择下面之一.

“用于 UEFI 计算机的 MBR 分区方案”: 若是 UEFI 方式安装,并且分区格式为 MBR,则选择此项

“用户 UEFI 计算机的 GPT 分区方案”: 若是 UEFI 方式安装,且分区格式为 GPT, 则选择此项(ps:若是与win10 共存,则选择此项)

![img](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%86%85%E5%AE%B9.assets/clip_image006.jpg)

图 5 方案选择

点击开始后，弹出的对话框保持默认即可。

![img](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%86%85%E5%AE%B9.assets/clip_image008.jpg)

图 6 写入模式选择

### Ubuntu的安装

1） 插上U盘，开机，当显示器点亮时按住F10（本人电脑启动项选择键是F10，你的也许不是F10，部分电脑是F12），进入启动项选择界面后，找到你的U盘，例如 UEFI SanDisk（注意：如果显示了两个，一定要选择UEFI格式的U盘），然后回车。
![img](20180328204350742.jpeg)
图4.1
2）选择Install Ubuntu，回车，会进入图4.2
![img](../个人收集资料/teached.img/20180328204526811.png)
图4.2
3）稍等片刻，会自动进入安装界面，如图4.3（注意：如果一直卡在图4.2，不要急，继续往下看）如果没问题，直接看图4.6
![img](../个人收集资料/teached.img/20180328204728102.png)
图4.3
如果一直卡在图4.2，请强制重启电脑，重复上面的步骤。注意，在进入图4.1时，选择Install Ubuntu，然后按键盘上的E键，进入图4.4	 
![img](../个人收集资料/teached.img/20180328205156192.jpeg)
图4.4
用方向键将标记移至quiet splash ---，将这句话修改为nouveau.modeset= 0，如图4.5	 
![img](../个人收集资料/teached.img/20180328205418372.jpeg)
图4.5
然后按F10，不出意外，将会进入安装界面。
4）在图4.3选择，选择汉语，安装Ubuntu，进入图4.6
![img](../个人收集资料/teached.img/20180328205831114.png)
图4.6
到这里你可以把两个选项都勾上，然后选择继续，点击继续后，这里会准备一段时间，时间较长，慢慢等待。准备完毕后，会进入下一个界面，
语言选择中文简体，继续
![img](../个人收集资料/teached.img/20180328210154224.jpeg)
图4.7
到图4.7，一定要选择其他选项，当然如果你的Windows系统盘足够大，或者不想使用Windows系统了可以试着选择其他选项。继续后进入图4.8
![img](../个人收集资料/teached.img/20180328210607360.jpeg)图4.8
在这个界面中找到步骤2中你压缩出来的那个空闲空间（注意，一定不要选择错了，否则，代价很惨）。然后左键双击可以进行分区，例如：
![img](../个人收集资料/teached.img/2018032821095847.jpeg)
图4.9
分区这里，可以参考：https://jingyan.baidu.com/article/4d58d5411380dd9dd5e9c07e.html这位博友的帖子。分区完成后，在安装启动引导器的设备一栏找到你的boot分区，一定不要选择错了，然后点击继续
![img](../个人收集资料/teached.img/20180328211624478.jpeg)
图4.10
![img](../个人收集资料/teached.img/20180328211752539.jpeg)
选择继续，
接下来会让你设置用户名和密码。自己设置一下就好了，设置完毕后会进入安装界面，耐心等待就好，安装完毕后选择重启。

5）电脑重启后，开机时按住F10，不出意外应该可以看到有Ubuntu的启动选项，选择Ubuntu选项，会进入一个类似图4.1的界面，注意：如果你的电脑在先前安装时不能直接进入安装界面，这里依然需要把quiet splash --- 这句话改成nouveau.modeset=0，f10后稍等会进入系统。没有这个问题的直接进入系统，没出现前面这个问题的兄弟后面的内容你就不用看了。

# 第二天：基本语法规则及变量

## 关键字、注释和文档
--------------
  保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 

```python
>>> import keyword
>>> keyword.kwlist
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```
----------

注释：使用#号，代表在本行中的#号之后的符号不会参与python表达，仅仅用来说明前面或者下一行的得带时用来做什么的。一般是写给程序的阅读者的。

-------------

文档一般使用<'''>进行包裹存在与代码块的起始位置。也是用来说以本段代码的作用以及说明。

## 内置函数

python为了方便我们的操作，在其内部内置了一些常见的函数，这些函数不需要我们进行任何操作，直接调用即可。

可以使用如下代码在交互模式下进行查看，对于我们知道如何使用的函数我们可以使用help内置函数在交互模式下查看帮助：

```python
>>> import sys
>>> dir(sys.modules['__builtin__'])
```

下面是内置函数的一个表格:

| | | 内置函数  |  ||
| --- | --- | ----- | --- | ---- |
| [abs()](http://www.runoob.com/python3/python3-func-number-abs.html) | [dict()](http://www.runoob.com/python/python-func-dict.html) | [help()](http://www.runoob.com/python/python-func-help.html) | [min()](http://www.runoob.com/python3/python3-func-number-min.html) | [setattr()](http://www.runoob.com/python/python-func-setattr.html) |
| [all()](http://www.runoob.com/python/python-func-all.html)   | [dir()](http://www.runoob.com/python/python-func-dir.html)   | [hex()](http://www.runoob.com/python/python-func-hex.html)   | [next()](http://www.runoob.com/python/python-func-next.html) | [slice()](http://www.runoob.com/python/python-func-slice.html) |
| [any()](http://www.runoob.com/python/python-func-any.html)   | [divmod()](http://www.runoob.com/python/python-func-divmod.html) | [id()](http://www.runoob.com/python/python-func-id.html)     | object()                                                     | [sorted()](http://www.runoob.com/python3/python3-func-sorted.html) |
| [ascii()](http://www.runoob.com/python3/python3-func-ascii.html) | [enumerate()](http://www.runoob.com/python3/python3-func-enumerate.html) | [input()](http://www.runoob.com/python/python3-func-input.html) | [oct()](http://www.runoob.com/python/python-func-oct.html)   | [staticmethod()](http://www.runoob.com/python/python-func-staticmethod.html) |
| [bin()](http://www.runoob.com/python/python-func-bin.html)   | [eval()](http://www.runoob.com/python/python-func-eval.html) | [int()](http://www.runoob.com/python/python-func-int.html)   | [open()](http://www.runoob.com/python3/python3-func-open.html) | [str()](http://www.runoob.com/python/python-func-str.html)   |
| [bool()](http://www.runoob.com/python/python-func-bool.html) | [exec()](http://www.runoob.com/python3/python3-func-exec.html) | [isinstance()](http://www.runoob.com/python/python-func-isinstance.html) | [ord()](http://www.runoob.com/python/python-func-ord.html)   | [sum()](http://www.runoob.com/python/python-func-sum.html)   |
| [bytearray()](http://www.runoob.com/python/python-func-bytearray.html) | [filter()](http://www.runoob.com/python3/python3-func-filter.html) | [issubclass()](http://www.runoob.com/python/python-func-issubclass.html) | [pow()](http://www.runoob.com/python3/python3-func-number-pow.html) | [super()](http://www.runoob.com/python/python-func-super.html) |
| [bytes()](http://www.runoob.com/python3/python3-func-bytes.html) | [float()](http://www.runoob.com/python/python-func-float.html) | [iter()](http://www.runoob.com/python/python-func-iter.html) | [print()](http://www.runoob.com/python/python-func-print.html) | [tuple()](http://www.runoob.com/python3/python3-func-tuple.html) |
| [callable()](http://www.runoob.com/python/python-func-callable.html) | [format()](http://www.runoob.com/python/att-string-format.html) | [len()](http://www.runoob.com/python3/python3-string-len.html) | [property()](http://www.runoob.com/python/python-func-property.html) | [type()](http://www.runoob.com/python/python-func-type.html) |
| [chr()](http://www.runoob.com/python/python-func-chr.html)   | [frozenset()](http://www.runoob.com/python/python-func-frozenset.html) | [list()](http://www.runoob.com/python3/python3-att-list-list.html) | [range()](http://www.runoob.com/python3/python3-func-range.html) | [vars()](http://www.runoob.com/python/python-func-vars.html) |
| [classmethod()](http://www.runoob.com/python/python-func-classmethod.html) | [getattr()](http://www.runoob.com/python/python-func-getattr.html) | [locals()](http://www.runoob.com/python/python-func-locals.html) | [repr()](http://www.runoob.com/python/python-func-repr.html) | [zip()](http://www.runoob.com/python3/python3-func-zip.html) |
| [compile()](http://www.runoob.com/python/python-func-compile.html) | [globals()](http://www.runoob.com/python/python-func-globals.html) | [map()](http://www.runoob.com/python/python-func-map.html)   | [reversed()](http://www.runoob.com/python3/python3-func-reversed.html) | [__import__()](http://www.runoob.com/python/python-func-__import__.html) |
| [complex()](http://www.runoob.com/python/python-func-complex.html) | [hasattr()](http://www.runoob.com/python/python-func-hasattr.html) | [max()](http://www.runoob.com/python3/python3-func-number-max.html) | [round()](http://www.runoob.com/python3/python3-func-number-round.html) |                                                              |
| [delattr()](http://www.runoob.com/python/python-func-delattr.html) | [hash()](http://www.runoob.com/python/python-func-hash.html) | [memoryview()](http://www.runoob.com/python/python-func-memoryview.html) | [set()](http://www.runoob.com/python/python-func-set.html)   |                                                              |

## 变量

变量概念来源于数学概念，是计算机中存储的数值、结果的一个抽象的表述方式。我们可以简单的理解为变量就是一个容器，它的值就是在这个容器中存储的一个我们要真实在程序中使用的数据。我们对变量的使用就是使用变量中的数据。

一般使用： 

变量名 = 值 的方式声明一个变量并给其赋值。如：

```python
name = '张三'
age ,height = 23 ,181
```

"del 变量名"  的方式销毁该变量。如：

```python
print(name)
del name
print(name)
```

扩展：

变量与值在内存中的关系:

1. 变量，通过变量指针引用对象变量指针指向具体对象的内存空间，取对象的值。

![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/bl1.png)

![](../%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/teached.img/bc2.jpg)

1. 对象，类型已知，每个对象都包含一个头部信息（头部信息：类型标识符和引用计数器）

   **注意：**变量名没有类型，类型属于对象（因为变量引用对象，所以类型随对象），变量引用什么类型的对象，变量就是什么类型的。

2. 在Python中，每个对象都有指向该对象的引用总数---引用计数。可以使用sys.getrefcount()查看该数值。

   **注意：** 当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。

3. 当我们销毁一个变量时，该变量指向的对象的引用次数将减少一次。

4. 当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾。

**小知识：**

1. id()是python的内置函数，用于返回对象的身份，即对象的内存地址。
2. 通过is进行引用所指判断，is是用来判断两个引用所指的对象是否相同。
3. Python缓存了整数和短字符串，因此每个对象在内存中只存有一份，引用所指对象就是相同的，即使使用赋值语句，也只是创造新的引用，而不是对象本身；
4. Python没有缓存长字符串、列表及其他对象，可以由多个相同的对象，可以使用赋值语句创建出新的对象。

## 基础变量类型及运算符

计算机程序的本质就是信息的处理，我们可以将世界上的信息使用以下集中简单形式进行表示（字符串、数字、布尔值，不存在），那么这些信息的形式类型就是我们在程序中使用的数据的类型即（str、number、bool、none）。这是我们构成世界的最基础的数据类型。在python中变量本身没有类型，它的类型由变量所指向的值确定。

### Python算术运算符

以下假设变量a为10，变量b为21：

| 运算符 | 描述                                            | 实例               |
| ------ | ----------------------------------------------- | ------------------ |
| +      | 加 - 两个对象相加                               | a + b 输出结果 31  |
| -      | 减 - 得到负数或是一个数减去另一个数             | a - b 输出结果 -11 |
| *      | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 210 |
| /      | 除 - x 除以 y                                   | b / a 输出结果 2.1 |
| %      | 取模 - 返回除法的余数                           | b % a 输出结果 1   |
| **     | 幂 - 返回x的y次幂                               | a**b 为10的21次方  |
| //     | 取整除 - 向下取接近除数的整数                   |                    |

### Python比较运算符

以下假设变量a为10，变量b为20：

| 运算符 | 描述                                                         | 实例                  |
| ------ | ------------------------------------------------------------ | --------------------- |
| ==     | 等于 - 比较对象是否相等                                      | (a == b) 返回 False。 |
| !=     | 不等于 - 比较两个对象是否不相等                              | (a != b) 返回 True。  |
| >      | 大于 - 返回x是否大于y                                        | (a > b) 返回 False。  |
| <      | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 | (a < b) 返回 True。   |
| >=     | 大于等于 - 返回x是否大于等于y。                              | (a >= b) 返回 False。 |
| <=     | 小于等于 - 返回x是否小于等于y。                              | (a <= b) 返回 True。  |

### Python赋值运算符

以下假设变量a为10，变量b为20：

| 运算符 | 描述             | 实例                                  |
| ------ | ---------------- | ------------------------------------- |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符   | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a               |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符     | c **= a 等效于 c = c ** a             |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a             |

### Python位运算符

 按位运算符是把数字看作二进制来进行计算的。

| 算符 | 描述                                                         | 实例                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| &    | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|   | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^    | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~    | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |
| <<   | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>   | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

### Python逻辑运算符

Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| ------ | ---------- | ------------------------------------------------------------ | ----------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

### Python成员运算符

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

| 运算符 | 描述                                                    | 实例                                              |
| ------ | ------------------------------------------------------- | ------------------------------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |

### Python身份运算符

  身份运算符用于比较两个对象的存储单元

| 运算符 | 描述                                        | 实例                                                         |
| ------ | ------------------------------------------- | ------------------------------------------------------------ |
| is     | is 是判断两个标识符是不是引用自一个对象     | **x is y**, 类似 **id(x) == id(y)** , 如果引用的是同一个对象则返回 True，否则返回 False |
| is not | is not 是判断两个标识符是不是引用自不同对象 | **x is not y** ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 |

### Python运算符优先级

以下表格列出了从最高到最低优先级的所有运算符：

| 运算符                   | 描述                                                   |
| ------------------------ | ------------------------------------------------------ |
| **                       | 指数 (最高优先级)                                      |
| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| * / % //                 | 乘，除，取模和取整除                                   |
| + -                      | 加法减法                                               |
| >> <<                    | 右移，左移运算符                                       |
| &                        | 位 'AND'                                               |
| ^ \|                     | 位运算符                                               |
| <= < > >=                | 比较运算符                                             |
| <> == !=                 | 等于运算符                                             |
| = %= /= //= -= += *= **= | 赋值运算符                                             |
| is is not                | 身份运算符                                             |
| in not in                | 成员运算符                                             |
| and or not               | 逻辑运算符                                             |

**扩展：**当我们书写表达式时按照PE8规范应该 总是在二元运算符两边加一个空格：赋值（=），增量赋值（+=，-=），比较（==,<,>,!=,<>,<=,>=,in,not,in,is,is not），布尔（and, or, not）。

如：

```python
x = 1
y = 2
long_variable = 3
i = i + 1
submitted += 1
x = x*2 - 1
```

## 输入输出

1. 我们在python中可以使用print函数将python中的内容输出至屏幕上，可以接受多个值。可以使用end指定结束符号，默认为（\n）回车符
2. Python提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。input 可以接收一个Python表达式作为输入，并将运算结果返回。 

**扩展**：

python文档查看

命令行键入 pydoc -p 8000

打开浏览器输入 localhost:8000 即可

# 第三天：逻辑控制

## 条件判断

写在前面的话：流程控制使我们第一次遇到需要缩进的语句，请注意**缩进格式**。**四个空格**一个缩进。

在条件判断中我们一般将表达式结果等价于bool之后进行分支判定，常见的运算为条件表达与逻辑运算。

### 分支流程语句（if语句）

#### 单分支1

```python
if 表达式:
    语句块1
print('Hello World')
```

流程：

```flow
st=>start: 开始
op1=>condition: 表达式结果
op2=>operation: 语句块1
ed=>end:  print('Hello World')
st->op1
op1(yes)->op2->ed
op1(no)->ed

```

#### 单分支2

```python
if 表达式:
    语句块1
else:
    语句块2

print('Hello World')
```

```flow
st=>start: 开始
con=>condition: 表达式结果
op1=>operation: 语句块1
op2=>operation: 语句块2
e=>end: print('Hello World')
st->con
con(yes)->op1->e
con(no)->op2->e
```

#### 多分支

```python
if 表达式1:
    语句块1
elif 表达式2:
    语句块2
else:
    表达式3

print('Hello World')
```

```flow
st=>start: 开始
con=>condition: 表达式1结果
con2=>condition: 表达式2结果
op1=>operation: 语句块1
op2=>operation: 语句块2
op3=>operation: 语句块3
e=>end: print('Hello World')
st->con
con(yes)->op1->e
con(no)->con2
con2(yes)->op2->e
con2(no)->op3->e
```

#### 总结：

1. 自上而下依次判断。
2. 任意依次判断成功，则进入本次子句，执行完之后忽略之后所有子句。
3. 若没有一次判定成功，则进入else子句。若无else则不执行任何子句操作。
4. 可以嵌套。

### 扩展：

#### 三元表达式

```python
a = 1
b = 2
h = ""

h = a-b if a>b else a+b

print(h)
```

其意义为：当a>b时，将a-b的结果赋值给h，否则将a+b的值赋给h

#### bool(布尔)

布尔有两个值，我们可以将任何对象放入bool函数中获取。字符串中的''、数字中的0、以及None在布尔运算中均等价于False

#### 练一练：

1. 阶段式工资计算。
2. 数值判定。
3. 判定成绩级别。

## 循环控制

### 前置知识：range

如果我们确实需要遍历一个数字序列，内置函数 `range()` 会派上用场。给定的终点不会包含在生成的序列中； `range（10）`会生成10个值，即长度为10的序列的项的合法索引。也可以让 range 函数从另一个数值开始，或者可以指定一个不同的步进值（甚至是负数，有时这也被称为‘步长’）。

### for遍历语句

**语法格式1：**

for 变量 in 可迭代对象：
​	语句块

**示例代码：**

```python
for x in range(10):
    '''
    语句块
    '''
    print(x)
```

**运行流程**

```flow
st=>start: 开始
op=>operation: 取出可迭代对象的下一个元素|pase
con=>condition: 是否取出成功
op1=>operation: 结果赋值给in前的变量
op2=>subroutine: 语句块
e=>end: 结束
st->op->con(yes)->op1->op2->e
con(no)->e
```

语法格式2：

for 变量 in 可迭代对象：
​	语句块
else：
​	语句块2

**示例代码：**

```python
for x in range(10):
    '''
    语句块
    '''
    print(x)
else:
    '''
    语句块二
    '''
    print('range中没有元素了')
```

**运行流程**

```flow
st=>start: 开始
op=>operation: 取出可迭代对象的下一个元素|pase
con=>condition: 是否取出成功
op1=>operation: 结果赋值给in前的变量
op2=>subroutine: 语句块
op3=>subroutine: 语句块2
e=>end: 结束
st->op->con(yes)->op1->op2->e
con(no)->op3->e
```

##### **练一练：**

1. 九九乘法表
2. 金字塔输出

### while循环语句

**语法格式1：**

while 表达式：
​	语句块

**示例代码：**

```python
n=0
while n<10:
    '''
    语句块
    '''
    print(n)
```

**运行流程**

```flow
st=>start: 开始
con=>condition: 表达式结果
op2=>subroutine: 语句块
e=>end: 结束
st->con(yes,right)->op2(left)->con(up)
con(no,down)->e
```

**语法格式2：**

while 表达式：
​	语句块
else：
​	语句块2

**示例代码：**

```python
n=0
while n<10:
    '''
    语句块
    '''
    print(n)
    n+=1
else:
    '''
    语句块二
    '''
    print('n的结果为：',n)
```

**运行流程**

```flow
st=>start: 开始
con=>condition: 表达式结果
op2=>subroutine: 语句块
op3=>subroutine: 语句块2
e=>end: 结束
st->con(yes,right)->op2(left)->con(up)
con(no,down)->op3->e
```

**注意：**

1. 循环时非必要情况下，不要实现死循环。
2. else语句并不是必不可少的。

**总结：**

1. 可以嵌套。
2. 判定结果为真运行循环体子句。
3. 当判定失败时，运行else子句之后结束循环。若无，则结束循环。
4. 当遇到continue语句时停止本次循环，进入下次循环。
5. 当遇到break语句时直接结束循环语句。

### 关于跳出

continue：遇到continue语句则不执行本次循环体中的continue之后的代码，直接进入下一个循环。无法跳过else子句。

break：遇到break语句则直接从当前位置跳出循环体执行之外的语句，注意else子句也将被跳过。

## 嵌套逻辑控制(练习)

1. 三次登录，超次退出

2. 裴波那切数列输出

3. 拼酒歌: 人在江湖飘 几刀砍死你。规则：2赢1，3赢2，4赢3，5赢4，1赢5,需要绝对值为1或4，abs:绝对值函数。

4. 报数游戏

   现在假如你和你的小伙伴一起玩报数游戏，从某一个人开始报数1，然后下一个报数2，一共100人，如果报数是3的倍数就报：哈哈哈，如果报数是5的倍数就报：呵呵呵，如果既是3的倍数，又是5的倍数就报：哈呵哈呵哈呵，需要遍历1-100

   结果应该类似：0,1,2，哈哈哈，4，呵呵呵，6……14，哈呵哈呵哈呵，16……

5. 这是一个非常简单的游戏。这里有 21 根棍子，首先用户选 1 到 4 根棍子，然后电脑选 1到 4 根棍子。谁选到最后一根棍子谁就输。你知道哪种情况用户会赢吗？

   特别说明：用户和电脑一次选的棍子总数只能是5。

6. 杨辉三角输出

## enumerate函数及案例

enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。

# 第四天：内置数据结构1

## 数值类型

### 数字的类型

整形(int)、浮点型(float)、复数(complex)

**注意：**受限与计算机硬件的影响，计算机中的浮点数有精度问题。

可以使用int、float、complex函数将可以转化的格式转为需要的数据。

### 数字的运算

python支持数学运算如：

| 运算符 | +    | -    | *    | /    | //   | %    | **   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 运算   | 加   | 减   | 乘   | 除   | 取商 | 取余 | 求幂 |

**注意：**除法的结果永远为浮点数。

因为浮点数有精度问题，尽量在设计运算的时候将有浮点数的运算最后运算，降低误差。

python的数字支持条件运算如：

| 运算符 | ==   | >    | >=       | <    | <=       | !=     |
| ------ | ---- | ---- | -------- | ---- | -------- | ------ |
| 说明   | 等于 | 大于 | 大于等于 | 小于 | 小于等于 | 不等于 |

**注意：**等于符号为"=="而不是"="，不要和我们上学时的数学符号搞混了。

python的数字支持逻辑运算如：

| 运算符                   | not                            | and                            | or                             |
| ------------------------ | ------------------------------ | ------------------------------ | ------------------------------ |
| 运算                     | 否定运算                       | 与运算                         | 或运算                         |
| 示例（假设 a=10,b=20）： | not a                          | a and b                        | a or b                         |
| 示例结果：               | Flase                          | 20                             | 10                             |
| 运算规则：               | 将运算符号右边的值转为布尔取反 | 前等价于True则为后值否则为前值 | 前等价于True则为前值否则为后值 |

### 数字的操作

我们可以使用python内置的一些模块及函数对数字进行操作处理。

如：

**上行取整**: math.ceil

```
In [2]: math.ceil(20.5)
Out[2]: 20

In [3]: math.ceil(20.1)
Out[3]: 20

```

进一法运算

**下行取整**: math.floor

```
In [5]: math.floor(20.8)
Out[5]: 20

In [6]: math.floor(20.008) 
Out[6]: 20

```

退一法运算

**截断取整**: math.trunc

```
In [8]: math.trunc(20.222) #取出20.222的整数部分
Out[8]: 20

```

获取数字的整数部分

**求幂指数:** math.pow

```
In [11]: math.pow(3,2) #计算3的2次幂
Out[11]: 9.0

In [12]: math.pow(3,6) #计算3的6次幂
Out[12]: 729.0

```

计算第一个参数的第二个参数次幂的结果

**√求开方:** math.sqrt

```
In [13]: math.sqrt(9) #给9开平方
Out[13]: 3.0

In [14]: math.sqrt(6) #给6开平方
Out[14]: 2.449489742783178

```

计算参数值的开方结果

**求对数值:**

格式1：math.log(x,[base])

说明：返回x以base为基数的对数，base默认为e即自然常数（可以时math.exp(1)获取，值为2.718281828459045）。

```
In [15]: math.log(4,2) #计算基数为2时4的对数
Out[15]: 2.0

In [16]: math.log(4,math.exp(1)) #基数为e时4的对数
Out[16]: 1.3862943611198906

In [17]: math.log(2,math.exp(1)) #基数为e时2的对数
Out[17]: 0.6931471805599453

In [18]: math.log(math.exp(1)) #基数为e时e的对数
Out[18]: 1.0


```

```
In [21]: math.log2(4) #计算基数为2时4的对数
Out[21]: 2.0

In [22]: math.log10(4) #计算基数为10时4的对数
Out[22]: 0.6020599913279624

```

**绝对值:** math.fabs()|abs()

```
In [28]: math.fabs(12)
Out[28]: 12.0

In [29]: math.fabs(-123)
Out[29]: 123.0

In [30]: abs(-12)
Out[30]: 12

```

**𝜋的常量:** math.pi

```
In [31]: math.pi
Out[31]: 3.141592653589793

```

**备注：**以上操作需要先导入内置的数学库（math）

**四舍五入:**  round(number[, ndigits])

说明：ngdigits是一个可选的参数，代表要保留的小数位，默认保留整数。

```
In [32]: round(3.353535,4)
Out[32]: 3.3535

In [33]: round(3.353535,3)
Out[33]: 3.354

In [34]: round(3.353535)
Out[34]: 3

```

### **练一练：**

1. 计算水仙花数。
2. 猜数字游戏。

## 序列

在Python中，最基本的数据结构是序列（sequence）。序列中的每个元素被分配一个序号——即元素的位置，也称为索引。第一个索引是 0，第二个则是 1，以此类推。序列中的最后一个元素标记为 -1，倒数第二个元素为 -2，一次类推。

```
Python包含 6 中内建的序列，包括列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。

```

sequence(序列)是一组有顺序的元素的集合(严格的说，是对象的集合，但鉴于我们还没有引入“对象”概念，暂时说元素)序列可以包含一个或多个元素，也可以是一个没有任何元素的空序列元素可以是我们之前所说的基本数据类型，可以是另一个序列，还可以是我们以后介绍的其他对象。

序列支持：成员检查（in）、索引（[index]）、切片（[start​ : end :​ step]）等运算。

注意：对于索引需要注意越界异常（IndexError: list index out of range）。

### 字符串

#### 字符串的创建

字符串字面量:把文本放入单引号、双引号或三引号中；
'    ''    '''

```python
>>> str1 = ' hello, fanison '
>>> type(str1)
str

```

如果要使用unicode编码，则在字符之前使用字符u进行标识

```python
>>> str2 = u'你好，fanison'
```

#### 字符串的转义

​	我们上面对于字符串定义的时候使用了单引号、双引号、三引号等符号。我们如果在字符串中要使用这些符号怎么办。这时就需要转义符来实现了。

​	其本质是使用一个“\”加上符号本身来表示这是一个符号而不是一个标识符（标记符）。如下‘\\’表示的是一个’\’符号而不是一个’\\’。Python中提供了另外一种字符串的写法简化了我们对于转义符号使用，就是在字符串前加上‘r’或者‘R’使得字符串中的所有符号以本身意义出现，而不涉及转义。

​	 如：r’\\’等价于R’\\’等价于’\\\\’

 	转义符详情参考附录部分，字符串转义表。

#### 扩展（文档字串）

模块、类或函数的第一条语句是一个字符的话，该 字符串就成为文档字符串，可以使用__doc__属性引用；
例：

```python
>>> def printName():
       "the function is print hello"
       print('hello')
>>> printName.__doc__

```

#### 字符串的运算

**运算符：**
索引运算符          		s[i]        返回一个序列的元素i
切片运算符          		s[i:j]      返回一个切片
扩展切片运算符     	s[i:j:stride]

例：

```python
>>> str3 = 'hello,fanison'
>>> str2[0:]
'hello,fanison'      返回所有元素
>>> str2[0:7]
'hello,f'            返回索引7之前的所有元素
>>> str2[0:7:2]
'hlof'               返回从索引0到6内步径为2的元素，即隔一个取一个
>>> str2[7:0:-2]        
'a,le'               从索引7处倒着隔一个取一个取到索引1处
>>> str2[-4:-1]
'iso'                从索引-4处取到-2处       
>>> str2[-4::-1]
'inaf,olleh'         从-4处到开始处倒着取

```

**注意：**
步径为正表示  正着取，索引从小到大          i < j
步径为负表示  倒着取，索引从大到小          i > j

**支持运算：**
组合（+）、重复（*）索引、切片、min()、max()、len()等

len(s)              	s中的元素个数
min(s)             	s的最小值
max(s)              	s的最大值

#### **相关重要方法：**

s.index(sub [,start [,end]])			找到指定字符串sub首次出现的位置
s.find(str,beg=0,end=len(string)) 	找到字符串sub首次出现位置，与index不同是不报错而返回-1
s.upper()                               			将一个字符串转换为大写形式
s.lower()                               			将一个字符串转化为小写形式
s.join(t)                               			使用s作为分隔符连接序列t中的字符串
s.strip()							将s两边不显示的符号去掉之后返回（lstrip、rstrip）
s.split(t)							获取以字符t将s切割的列表
s.encode()						获取s的指定编码的bytes值
bytes.decode()					获取bytes的对应编码的字符串，在python2中使用decode函数
s.endswith(suffix,beg=0, end=len(string))检查中是否以suffix字符串结尾

示例：

```
>>> l1 = list(str1)
>>> l1
['h', 'e', 'l', 'l', 'o', ',', 'f', 'a', 'n', 'i', 's', 'o', 'n']
>>> ''.join(l1)
'hello,fanison'             使用空字符作为分隔符连接列表l1
S.replace(old, new[, count])             替换一个字符串
>>> str1.replace('fan','FAN')
'hello,FANison'

```

s.translate()					方法,替换某个字符

示例代码：

```
intab = "aeiou"
outtab = "12345"
trantab = str.maketrans(intab, outtab)   # 制作翻译表

s = "this is string example....aeiou  ... !!!"
print(s.translate(trantab))

```

**注意：**
使用 help()获取其帮助

```
>>> help(str.join)

```

#### 扩展（字符串格式化）

 Python中我们可以通过字符串格式化的方式对字符串进行定义，主要有两种格式化方法，一种为类似c语言元字符的方式、一种使用其自身的format方法进行：

##### 元字符方式：

 格式1：% (name) [width].[precision]typecode

 示例:

```
In [50]: '%(name)+10s-----------%(age)-10d--------'%{'name':'xx','age':20.5}
Out[50]: '        xx-----------20        --------'

```

其操作的流程是将后面的由%引导的【字典】中的元素按照key与前面%中的（name）对应顺序的值按照其元字符及辅助操作符的限定对应填充。

格式2：%  flags .[precision]typecode

示例:

```
In [49]: '%+10s-----------%-10d--------'%('xx',20.5)
Out[49]: '        xx-----------20        --------'

```

其操作的流程是将后面的由%引导的【元组】中的每一个元素与前面%对应顺序的值按照其元字符及辅助操作符的限定对应填充。注意：前后数量必须保持一致，类型需要保证可以转换。

flags为元字符辅助操作符、typecode为元字符，具体符号相见附录部分【字符串元字符速查表】。

##### Format方式：

用法：它通过{}和:来代替传统%方式

1. 使用位置参数

   要点：从以下例子可以看出位置参数不受顺序约束，且可以为{},只要format里有相对应的参数值即可,参数索引从0开，传入位置参数列表可用*列表

   ```
   >>> li = ['hoho',18]
   >>> 'my name is {} ,age {}'.format('hoho',18)
   'my name is hoho ,age 18'
   >>> 'my name is {1} ,age {0}'.format(10,'hoho')
   'my name is hoho ,age 10'
   >>> 'my name is {1} ,age {0} {1}'.format(10,'hoho')
   'my name is hoho ,age 10 hoho'
   >>> 'my name is {} ,age {}'.format(*li)
   'my name is hoho ,age 18'
   
   ```

2. 使用关键字参数

   要点：关键字参数值要对得上，可用字典当关键字参数传入值，字典前加**即可

   ```
   >>> hash = {'name':'hoho','age':18}
   >>> 'my name is {name},age is {age}'.format(name='hoho',age=19)
   'my name is hoho,age is 19'
   >>> 'my name is {name},age is {age}'.format(**hash)
   'my name is hoho,age is 18'
   
   ```

3. 填充与格式化

   :填充字符[宽度]

   ```
    >>> '{0:*>10}'.format(10)  ##右对齐
    '********10'
    >>> '{0:*<10}'.format(10)  ##左对齐
    '10********'
    >>> '{0:*^10}'.format(10)  ##居中对齐
    '****10****'
   
   ```

4. 精度与进制

   ```
   >>> '{0:.2f}'.format(1/3)
   '0.33'
   >>> '{0:b}'.format(10)    #二进制
   '1010'
   >>> '{0:o}'.format(10)     #八进制
   '12'
   >>> '{0:x}'.format(10)     #16进制
   'a'
   >>> '{:,}'.format(12369132698)  #千分位格式化
   '12,369,132,698'
   
   ```

5. 使用索引

   ```
   >>> li
   ['hoho', 18]
   >>> 'name is {0[0]} age is {0[1]}'.format(li)
   'name is hoho age is 18
   
   ```

### 列表

列表：容器类型
任意对象的有序集合，通过索引访问其中的元素，可变对象，长度可变，异构，任意嵌套
支持在原处修改修改指定的索引元素，修改指定的分片，删除语句，内置方法

```
>>> list1 = [ 1,2,3,'x','n' ]
>>> list1[1]=56
>>> print(list1)
[1, 56, 3, 'x', 'n']
>>> list1[1:3]=[]              会删除索引1到索引3之前的元素
>>> print(list1)
[1, 'x', 'n']   
>>> del(list1[1])              使用del函数删除list索引为1的元素
>>> print(list1)
[1, 'n']

```

**注意：**因为支持原处修改，不会改变内存位置，可使用  id() 查看其位置变化

#### 内置方法：

L.count(value)                     计算value值出现的次数
L.append(object)                   将一个新元素追加到L末端                   L.extend(iterable)                 增加合并列表(第二个列表内容会以单个元素追加至末端)

```
>>> l1 = [ 1,2,3 ]
>>> l2 = [ 'x','y','z']
>>> l1.append(l2)		#使用append方法会以其原有存在形式追加
>>> l1
[1, 2, 3, ['x', 'y', 'z']]          
>>> l1 = [ 1,2,3 ]
>>> l1.extend(l2)		
>>> l1				 #注意两种增加的区别
[1, 2, 3, 'x', 'y', 'z']

```

L.pop([index])                      返回元素index并从列表中移除它，如果省略则返回并移除列表最后一个元素
L.remove(key)                       移除值为key的元素

```
>>> l1 = [ 'x',2,'abc',16,75 ]
>>> l1.pop(2)                       #pop方法是按索引移除
'abc'
>>> l1
['x', 2, 16, 75]
>>> l1.remove(16)                 # remove方法是按值移除
>>> l1
['x', 2, 75] 

```

L.index(value)                        指定值首次出现的位置
L.insert(index, object)               在索引index处插入值

```
>>> l1.insert(1,'abc')
>>> l1
['x', 'abc', 2, 75]

```

L.sort(reverse=True)           排序reverse默认为False升序
L.reverse()                           逆序

```
>>> l1.sort()
[2, 75, 'abc', 'x']
>>> l1.reverse()
['x', 'abc', 75, 2]

```

#### 列表运算

l1 + l2: 合并两个列表，返回一个新的列表；不会修改原列表；

```
>>> l1 = [ 1,2,3]
>>> l2 = [ 'x','y','z']
>>> l1 + l2
[1, 2, 3, 'x', 'y', 'z']

```

l1 * N: 把l1重复N次，返回一个新列表; 

```
>>> l1 * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3] 

```

使用id()查看是否生成新列表
成员关系判断字符：

```
in              用法：   item in container
not in               item not in container
>>> l1 = [ 'x','y',3 ]
>>> 'y' in l1
True
>>> 'x' not in l1
False

```

列表解析：[]

#### 扩展:

##### 列表复制方式

浅复制:两者指向同一内存对象

```
>>> l1 = [ 1,2,3,4 ]
>>> l2 = l1
>>> id(l1) == id(l1)	# 可以看出两者内存地址相同
True            
>>> l1.append('x')
>>> print(l1)
[ 1,2,3,4,'x' ]
>>> print(l2)
[ 1,2,3,4,'x' ]

```

深复制：两者指向不同内存对象
1)导入copy模块，使用deepcoop方法

```
>>> import copy
>>> l3 = copy.deepcopy(l1)
>>> id(l3) == id(l1)		#可以看出来地址不同
False                          

```

2)复制列表的所有元素，生成一个新列表

```
>>> l4 = l1[:]              
>>> print(l4)
[ 1,2,3,4,'x' ]
>>> l1.append(6)
>>> print(l1)		#可以看出来l1发生了改变
[ 1,2,3,4,'x',6 ]               
>>> print(l4)		#可以看出来l4未发生变化
[ 1,2,3,4,'x' ]

```

##### 列表推导式

python中列表推导式提供了一种创建list的简便方法。应用程序创建列表时，列表中的元素来源于其他序列、可迭代对象或创建的一个满足一定条件的序列。

例如，假设我们要创建一个平方数组成的列表，比如：

```python
squares = []
for x in range(10):
    squares.append(x**2)
print(squares)
```

输出结果：

```pyton
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

我们也可以通过下面的方式获得相同的列表：

```python
squares = [x**2 for x in range(10)]
```

列表推导式包含一对括号，在括号中有一个表达式，表达式后面紧跟一条for语句，然后是零条或多条，for语句或if语句。通过for语句和if语句计算出表达式，结果作为新列表的元素。例如，下面的列表推导式将两个不同列表中的元素整合到了一起：

```python
>>> [(x,y)for x in [1,2,3] for y in [3,1,4] if x != y]
>>> [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

这等价于：

```python
>>> combs = []
>>> for x in [1,2,3]:
>>> for y in [3,1,4]:
>>> if x != y:
>>> combs.append((x,y))

>>> combs
>>> [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

**注意:**for语句和if语句在这两段程序片中的顺序是相同的。

列表推导式可以包含复杂表达式和嵌套函数：

```python
>>> from math import pi
>>> [str(round(pi,i)) for i in range(1,6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

列表推导式也可以和列表推倒式嵌套：

```python
>>> matrix = [
	[1,2,3,4],
	[5,6,7,8],
	[9,10,11,12],
	]
>>> matrix
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
>>> [[row_list[j] for row_list in matrix]for j in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

### 元组

表达式符号：()
容器类型
任意对象的有序集合，通过索引访问其中的元素，不可变对象，长度固定，异构，嵌套

#### 常见操作：

```python
>>> t1 = ( 1,2,3,'xyz','abc')
>>> type(t1)
tuple
>>> len(t1)
5
>>> t2 = ()                                  # 定义一个空元组
>>> t3 = ( , )			 	#报错：使用逗号分隔的条件是最少要有一个元素如：(1,)
SyntaxError: invalid syntax             
>>> t1[:]
( 1,2,3,'xyz','abc' )
>>> t1[1:]
(2, 3, 'xyz', 'abc')
(1,2)       
>>> t1[1:4]
(2, 3, 'xyz')
>>> t4 = 'x',1,'yz',45,[2,4,6]             # 注意!!!这样也可以生成元组
>>> t4  
('x', 1, 'yz', 45, [2, 4, 6])
```

t1 + t4: 合并两个元组，返回一个新的元组；不会修改原元组；

```python
>>> t1 + t4
(1, 2, 3, 'xyz', 'abc', 'x', 1, 'yz', 45, [2, 4, 6])
```

t1 * N:  把l1重复N次，返回一个新元组; 

```python
>>> t1 * 3
(1, 2, 3, 'xyz', 'abc', 1, 2, 3, 'xyz', 'abc', 1, 2, 3, 'xyz', 'abc')
```

成员关系判断：in、not in

注意：虽然元组本身不可变，但如果元组内嵌套了可变类型的元素，那么此类元素的修改不会返回新元组；
例：

```python
>>> t4 = ('x', 1, 'yz', 45, [2, 4, 6])
>>> id(t4)
44058448
>>> t4[4]                           
[2, 4, 6]
>>> t4[4].pop()                     #弹出列表内一个元素
6
>>> print(t4[4])
[2, 4]
>>> print(t4)
('x', 1, 'yz', 45, [2, 4]) 
>>> id(t4)			#由此可见，对元组内列表内的修改也会使元组发生改变，没有返回新元组
44058448                            
```

## 案例

排序（冒泡）算法

## 作业：

1、计算1000以内的自幂数  即数字的每个位的数字的长度次幂之和等于其自身的数字，两种方法。

2、获取文件夹中所有的mp3文件的名字。可以使用 os.listdir(文件目录路径)获取文件名列表。

3、计算8000的质因数有哪些并输出。

4、杨辉三角输出。

5、请使用程序过滤掉一个字符串中的敏感字:法轮功，淫，黄色。替换成\*\*\*,\*,\*\*这种形式。使用两种形式。

6、使用冒泡算法对一个字符串进行排序。

# 第五天：内置数据结构2

## 字典

### 字典定义

1. 以"{}"包裹元素。
2. 以key-value(键值对)的形式存储元素。
3. 以key:value表示一个元素, 元素之间用逗号隔开。
4. 注意事项：字典的key只能为不可变类型对象。

### 字典操作

#### 字典的访问：

1. 以dict_name[key]的方式访问其key对应的值（如果key不存在则报错）。

2. 使用字典的get方法获取（如果key不存在, 则返回None）。

3. 使用字典的setdefault方法（若key存在获取，否则按照默认值设置并获取）

   ```python
   In [90]: dic={'name':'zhang3',2:30}
   
   [91]: dic['name']
   Out[91]: 'zhang3'
   
   In [92]: dic.get(2)
   Out[92]: 30
   
   In [94]: dic.setdefault(2,5)
   Out[94]: 30
   
   In [95]: dic
   Out[95]: {'name': 'zhang3', 2: 30}
   
   In [96]: dic.setdefault(5,3)
   Out[96]: 3
   
   In [97]: dic
   Out[97]: {'name': 'zhang3', 2: 30, 5: 3}
   ```

#### 字典的修改:

1. 以dict_name[key]=value的方式修改key对应的值（如果不存在则新增）。
2. 使用update方法的方式（将新字典的值更新至原来的字典）。
3. 使用setdefault方法添加一个元素。

#### 字典的删除：

1. 使用pop(key)的方法。
2. 使用clear清理。
3. 使用del删除语句。
4. 使用popitem()随机删除一个item。
5. 使用 in判定key是否存在。

#### 字典的遍历：

1. 使用key进行遍历。

   ```python
   dict1 = {'tom': 12, 'helen': 23, 'leo': 24, 'nick': 88}
   print(dict1.keys())
   for key in dict1.keys():
       print(key, dict1[key]
   ```

2. 遍历字典的key。

   ```python
   dict1 = {'tom': 12, 'helen': 23, 'leo': 24}
   for key in dict1:
       print(key, dict1[key])
   ```

3. 通过item遍历。

   ```python
   print(dict1.items())
   for key, value in dict1.items():
       print(key, value)
   ```

4. 使用enumerate 枚举函数遍历

   ```python
   for index, key in enumerate(dict9):
       print(index, key)
   ```

### 字典特点

1. 字典本身是可变类型
2. 极快的查找速度;
3. key具有唯一性;
4. key具有无序性;
5. key需要不可变数据类型(字符串, 数字);
6. 当key重复的时候, 只保留一个, 自动舍弃其他值

### 与list比较

list：插入和查询速度比较慢，随着元素个数的增加会对查找速度产生过大的影响；占用较小内存，内存浪费少。

dict：插入和查询速度比较快，随着元素个数的增加不会对查找速度产生过大影响；占用较大内存，内存浪费多。

### 扩展（zip并行遍历）

## 集合

### 定义

定义: 与字典类似, 一组key的集合, 没有value，使用{}定义，空集合只能使用set()方式定义。

### 特点

1. 无序;
2. 不可重复;
3. 可以用来去除重复的元素;
4. 空的集合是字典类型;
5. 不能直接修改其中的元素;
6. 如果一个元素原来就在某个集合中, 则无法再次添加该元素

### 操作

**添加单个元素**(更新): .add

```python
set1 = set([12,23,45,89,66,66,23])
set1.add(888)
print(set1)
```

**添加多个元素**(更新): .update

```python
set1 = set([12,23,45,89,66,66,23])
set1.update((888,999,89))
print(set1)
```

**删除元素**(删): .remove

```python
set2 = set([12,23,45,89,66,66,23])
set2.remove(45)
print(set2)
```

set集合还有pop方法和clear方法。

### 运算

**交集(&):** 求相同部分

```python
set1 = set([12, 23, 78, 999])
set2 = set([12, 45, 89, 78, 333])
set3 = set1 & set2 
print(set3)
```

**并集(|):** 合并两个集合

```python
set1 = set([12, 23, 78, 999])
set2 = set([12, 45, 89, 78, 333])
set3 = set1 | set2 
print(set3)
```

**差集(-): ** 和另一个集合不重合的部分

```
set1 = set([12, 23, 78, 999])
set2 = set([12, 45, 89, 78, 333])
set3 = set1 - set2 
print(set3)

```

注意：集合没有+、*运算。

## 特殊数据结构介绍

我们都知道，Python拥有一些内置的数据类型，比如str, int, list, tuple, dict等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：

- `namedtuple()`: 生成可以使用名字来访问元素内容的tuple子类
- `deque`: 双端队列，可以快速的从另外一侧追加和推出对象
- `Counter`: 计数器，主要用来计数
- `OrderedDict`: 有序字典
- `defaultdict`: 带有默认值的字典

### namedtuple()

namedtuple主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性， 在访问一些tuple类型的数据时尤其好用。

**示例代码：**

```python
# -*- coding: utf-8 -*-
"""
比如我们用户拥有一个这样的数据结构，每一个对象是拥有三个元素的tuple。
使用namedtuple方法就可以方便的通过tuple来生成可读性更高也更好用的数据结构。
"""
from collections import namedtuple

websites = [
    ('Sohu', 'http://www.google.com/', u'张朝阳'),
    ('Sina', 'http://www.sina.com.cn/', u'王志东'),
    ('163', 'http://www.163.com/', u'丁磊')
]

Website = namedtuple('Website', ['name', 'url', 'founder'])

for website in websites:
    website = Website._make(website)
    print website


# Result:
Website(name='Sohu', url='http://www.google.com/', founder=u'\u5f20\u671d\u9633')
Website(name='Sina', url='http://www.sina.com.cn/', founder=u'\u738b\u5fd7\u4e1c')
Website(name='163', url='http://www.163.com/', founder=u'\u4e01\u78ca')
```

### deque

deque其实是 `double-ended queue` 的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列 头部快速增加和取出对象: `.popleft()`, `.appendleft()` 。

你可能会说，原生的list也可以从头部添加和取出对象啊？就像这样：

```python
l.insert(0, v)
l.pop(0)
```

但是值得注意的是，list对象的这两种用法的时间复杂度是 `O(n)` ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 `O(1)` 的复杂度，所以当你的代码有这样的需求的时候， 一定要记得使用deque。

作为一个双端队列，deque还提供了一些其他的好用方法，比如 `rotate` 等。

**示例代码：**

```python
# -*- coding: utf-8 -*-
"""
下面这个是一个有趣的例子，主要使用了deque的rotate方法来实现了一个无限循环
的加载动画
"""
import sys
import time
from collections import deque

fancy_loading = deque('>--------------------')

while True:
    print '\r%s' % ''.join(fancy_loading),
    fancy_loading.rotate(1)
    sys.stdout.flush()
    time.sleep(0.08)

# Result:

# 一个无尽循环的跑马灯
------------->-------
```

### Counter

计数器是一个非常常用的功能需求，collections也贴心的为你提供了这个功能。

**示例代码：**

```python
# -*- coding: utf-8 -*-
"""
下面这个例子就是使用Counter模块统计一段句子里面所有字符出现次数
"""
from collections import Counter

s = '''A Counter is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.'''.lower()

c = Counter(s)
# 获取出现频率最高的5个字符
print c.most_common(5)


# Result:
[(' ', 54), ('e', 32), ('s', 25), ('a', 24), ('t', 24)]
```

### OrderedDict

在Python中，dict这个数据结构由于hash的特性，是无序的，这在有的时候会给我们带来一些麻烦， 幸运的是，collections模块为我们提供了OrderedDict，当你要获得一个有序的字典对象时，用它就对了。

**示例代码：**

```python
# -*- coding: utf-8 -*-
from collections import OrderedDict

items = (
    ('A', 1),
    ('B', 2),
    ('C', 3)
)

regular_dict = dict(items)
ordered_dict = OrderedDict(items)

print 'Regular Dict:'
for k, v in regular_dict.items():
    print k, v

print 'Ordered Dict:'
for k, v in ordered_dict.items():
    print k, v


# Result:
Regular Dict:
A 1
C 3
B 2
Ordered Dict:
A 1
B 2
C 3
```

### defaultdict

我们都知道，在使用Python原生的数据结构dict的时候，如果用 `d[key]` 这样的方式访问， 当指定的key不存在时，是会抛出KeyError异常的。

但是，如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值。

**示例代码：**

```python
# -*- coding: utf-8 -*-
from collections import defaultdict

members = [
    # Age, name
    ['male', 'John'],
    ['male', 'Jack'],
    ['female', 'Lily'],
    ['male', 'Pony'],
    ['female', 'Lucy'],
]

result = defaultdict(list)
for sex, name in members:
    result[sex].append(name)

print result

# Result:
defaultdict(<type 'list'>, {'male': ['John', 'Jack', 'Pony'], 'female': ['Lily', 'Lucy']})
```

## 案例

中英文翻译程序的实现



# 附录：

## 字符串转义字符表

在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。如下表：

| 转义字符    | 描述                                         |
| ----------- | -------------------------------------------- |
| \(在行尾时) | 续行符                                       |
| \\          | 反斜杠符号                                   |
| \'          | 单引号                                       |
| \"          | 双引号                                       |
| \a          | 响铃                                         |
| \b          | 退格(Backspace)                              |
| \e          | 转义                                         |
| \000        | 空                                           |
| \n          | 换行                                         |
| \v          | 纵向制表符                                   |
| \t          | 横向制表符                                   |
| \r          | 回车                                         |
| \f          | 换页                                         |
| \oyy        | 八进制数，yy代表的字符，例如：\o12代表换行   |
| \xyy        | 十六进制数，yy代表的字符，例如：\x0a代表换行 |
| \other      | 其它的字符以普通格式输出                     |

## python字符串格式化符号表

| 符   号 | 描述                                 |
| ------- | ------------------------------------ |
| %c      | 格式化字符及其ASCII码                |
| %s      | 格式化字符串                         |
| %d      | 格式化整数                           |
| %u      | 格式化无符号整型                     |
| %o      | 格式化无符号八进制数                 |
| %x      | 格式化无符号十六进制数               |
| %X      | 格式化无符号十六进制数（大写）       |
| %f      | 格式化浮点数字，可指定小数点后的精度 |
| %e      | 用科学计数法格式化浮点数             |
| %E      | 作用同%e，用科学计数法格式化浮点数   |
| %g      | %f和%e的简写                         |
| %G      | %f 和 %E 的简写                      |
| %p      | 用十六进制数格式化变量的地址         |

## 格式化操作符辅助指令表

| 符号  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 定义宽度或者小数点精度                                       |
| -     | 用做左对齐                                                   |
| +     | 在正数前面显示加号( + )                                      |
| <sp>  | 在正数前面显示空格                                           |
| #     | 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') |
| 0     | 显示的数字前面填充'0'而不是默认的空格                        |
| %     | '%%'输出一个单一的'%'                                        |
| (var) | 映射变量(字典参数)                                           |
| m.n.  | m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)        |

## 字符串内建方法表

| 序号 | 方法                                            | 描述                                                         |
| ---- | ----------------------------------------------- | ------------------------------------------------------------ |
| 1    | capitalize()                                    | 将字符串的第一个字符转换为大写                               |
| 2    | center(width, fillchar)                         | 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 |
| 3    | count(str, beg= 0,end=len(string))              | 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |
| **4  | bytes.decode(encoding="utf-8", errors="strict") | Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 |
| **5  | encode(encoding='UTF-8',errors='strict')        | 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |
| **6  | endswith(suffix, beg=0, end=len(string))        | 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |
| 7    | expandtabs(tabsize=8)                           | 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 |
| **8  | find(str, beg=0 end=len(string))                | 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 |
| 9    | index(str, beg=0, end=len(string))              | 跟find()方法一样，只不过如果str不在字符串中会报一个异常.     |
| 10   | isalnum()                                       | 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False |
| 11   | isalpha()                                       | 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False |
| 12   | isdigit()                                       | 如果字符串只包含数字则返回 True 否则返回 False..             |
| 13   | islower()                                       | 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |
| 14   | isnumeric()                                     | 如果字符串中只包含数字字符，则返回 True，否则返回 False      |
| 15   | isspace()                                       | 如果字符串中只包含空白，则返回 True，否则返回 False.         |
| 16   | istitle()                                       | 如果字符串是标题化的(见 title())则返回 True，否则返回 False  |
| 17   | isupper()                                       | 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |
| **18 | join(seq)                                       | 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |
| *19  | len(string)                                     | 返回字符串长度                                               |
| 20   | ljust(width[, fillchar\])                       | 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 |
| 21   | lower()                                         | 转换字符串中所有大写字符为小写.                              |
| 22   | lstrip()                                        | 截掉字符串左边的空格或指定字符。                             |
| **23 | maketrans()                                     | 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 |
| *24  | max(str)                                        | 返回字符串 str 中最大的字母。                                |
| *25  | min(str)                                        | 返回字符串 str 中最小的字母。                                |
| **26 | replace(old, new [, max\])                      | 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 |
| 27   | rfind(str, beg=0,end=len(string))               | 类似于 find()函数，不过是从右边开始查找.                     |
| 28   | rindex( str, beg=0, end=len(string))            | 类似于 index()，不过是从右边开始.                            |
| 29   | rjust(width,[, fillchar\])                      | 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 |
| 30   | rstrip()                                        | 删除字符串字符串末尾的空格.                                  |
| **31 | split(str="", num=string.count(str))            | num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 |
| **32 | splitlines([keepends\])                         | 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |
| **33 | startswith(str, beg=0,end=len(string))          | 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 |
| **34 | strip([chars\])                                 | 在字符串上执行 lstrip()和 rstrip()                           |
| 35   | swapcase()                                      | 将字符串中大写转换为小写，小写转换为大写                     |
| 36   | title()                                         | 返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |
| **37 | translate(table, deletechars="")                | 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 |
| 38   | upper()                                         | 转换字符串中的小写字母为大写                                 |
| 39   | zfill (width)                                   | 返回长度为 width 的字符串，原字符串右对齐，前面填充0         |
| 40   | isdecimal()                                     | 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 |

**备注： **  *标记为相关内建函数，**标记为常用方法。

## Python列表函数&方法

Python包含以下函数:

| 序号 | 函数       | 描述               |
| ---- | ---------- | ------------------ |
| 1    | [len(list) | 列表元素个数       |
| 2    | [max(list) | 返回列表元素最大值 |
| 3    | [min(list) | 返回列表元素最小值 |
| 4    | [list(seq) | 将元组转换为列表   |

Python包含以下方法:

| 序号 | 方法                                         | 描述                                                         |
| ---- | -------------------------------------------- | ------------------------------------------------------------ |
| 1    | list.append(obj)                             | 在列表末尾添加新的对象                                       |
| 2    | list.count(obj)                              | 统计某个元素在列表中出现的次数                               |
| 3    | list.extend(seq)                             | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| 4    | list.index(obj)                              | 从列表中找出某个值第一个匹配项的索引位置                     |
| 5    | list.insert(index, obj)                      | 将对象插入列表                                               |
| 6    | list.pop([index=-1\])                        | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| 7    | list.remove(obj)                             | 移除列表中某个值的第一个匹配项                               |
| 8    | list.reverse()                               | 反向列表中元素                                               |
| 9    | list.sort(cmp=None, key=None, reverse=False) | 对原列表进行排序                                             |
| 10   | list.clear()                                 | 清空列表                                                     |
| 11   | list.copy()                                  | 复制列表                                                     |

## Python字典内置方法

| 序号 | 函数                                                        | 描述                                                         |
| ---- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | radiansdict.clear()                                         | 删除字典内所有元素                                           |
| 2    | radiansdict.copy()                                          | 返回一个字典的浅复制                                         |
| 3    | radiansdict.fromkeys()                                      | 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |
| 4    | radiansdict.get(key, default=None)                          | 返回指定键的值，如果值不在字典中返回default值                |
| 5    | key in dict                                                 | 如果键在字典dict里返回true，否则返回false                    |
| 6    | radiansdict.items()                                         | 以列表返回可遍历的(键, 值) 元组数组                          |
| 7    | radiansdict.keys()                                          | 返回一个迭代器，可以使用 list() 来转换为列表                 |
| 8    | radiansdict.setdefault(key, default=None)                   | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
| 9    | radiansdict.update(dict2)                                   | 把字典dict2的键/值对更新到dict里                             |
| 10   | radiansdict.values()                                        | 返回一个迭代器，可以使用 list() 来转换为列表                 |
| 11   | pop(key[,default\])                                         | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |
| 12   | popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。 |                                                              |

## 集合内置方法完整列表

| 序号 | 方法                          | 描述                                                         |
| ---- | ----------------------------- | ------------------------------------------------------------ |
| 1    | add()                         | 为集合添加元素                                               |
| 2    | clear()                       | 移除集合中的所有元素                                         |
| 3    | copy()                        | 拷贝一个集合                                                 |
| 4    | difference()                  | 返回多个集合的差集                                           |
| 5    | difference_update()           | 移除集合中的元素，该元素在指定的集合也存在。                 |
| 6    | discard()                     | 删除集合中指定的元素                                         |
| 7    | intersection()                | 返回集合的交集                                               |
| 8    | intersection_update()         | 删除集合中的元素，该元素在指定的集合中不存在。               |
| 9    | isdisjoint()                  | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 |
| 10   | issubset()                    | 判断指定集合是否为该方法参数集合的子集。                     |
| 11   | issuperset()                  | 判断该方法的参数集合是否为指定集合的子集                     |
| 12   | pop()                         | 随机移除元素                                                 |
| 13   | remove()                      | 移除指定元素                                                 |
| 14   | symmetric_difference()        | 返回两个集合中不重复的元素集合。                             |
| 15   | symmetric_difference_update() | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |
| 16   | union()                       | 返回两个集合的并集                                           |
| 17   | update()                      | 给集合添加元素                                               |

